LX51 LINKER/LOCATER V4.66.41.0                                                          06/14/2016  11:14:41  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  ..\build\obj\silabs_c2adapter (THREAD_PKT)


----- FUNCTION DRV_Entry (BEGIN) -----
 FILE: '..\drv\drv.c'
   36: void DRV_Entry(void)
   37: {
   38:     /* do nothing */
   39: }
00002A 22                RET      
----- FUNCTION DRV_Entry (END) -------


00002B 0227A5            LJMP     027A5H
----- FUNCTION APL_Init (BEGIN) -----
 FILE: '..\apl\apl.c'
   56: void APL_Init(void)
;----                  JMP      APL_Entry
   57: {
   58:     /* perform entry once */
----- FUNCTION APL_Init (END) -------


----- FUNCTION APL_Entry (BEGIN) -----
 FILE: '..\apl\apl.c'
   36: void APL_Entry(void)
   37: {
   38:     /* do nothing */
   39: }
000086 22                RET      
----- FUNCTION APL_Entry (END) -------


----- FUNCTION DRV_VECTOR_UserUSB (BEGIN) -----
 FILE: '..\drv\drv_vector.c'
   65: void DRV_VECTOR_UserUSB(void) __interrupt(INTERRUPT_UserUSB)
   66: {
   67:   #if PKT_SUPPORT
   68: 	thread_Pkt_Notify(DRV_USB_GetInterruptSource());
   69:   #endif
   70: }
000087 32                RETI     
----- FUNCTION DRV_VECTOR_UserUSB (END) -------


00008B 80FA              SJMP     01000087H
----- FUNCTION thread_IDLE_Entry (BEGIN) -----
 FILE: '..\plf\thread_idle.c'
   38: OS_HANDLE thread_IDLE_Entry(void)
   39: {
   40:     PT_BEGIN(&vTCB_Idle);
   41: 
001A58 752401            MOV      PT_YIELD_FLAG,#01H
001A5B         ?C0001?THREAD_IDLE:
001A5B E50C              MOV      A,vTCB_Idle
001A5D 7038              JNZ      ?C0002?THREAD_IDLE
001A5F E50D              MOV      A,vTCB_Idle+01H
001A61 24CF              ADD      A,#0CFH
001A63 601D              JZ       ?C0012?THREAD_IDLE
001A65 2431              ADD      A,#031H
001A67 702E              JNZ      ?C0002?THREAD_IDLE
   42:     for (;;)
001A69         ?C0004?THREAD_IDLE:
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 2


   43:     {
   44:     	/* system entry */
   45:         CFG_Entry();
   46:         DRV_Entry();
001A69 12002A            LCALL    DRV_Entry
   47:         APL_Entry();
001A6C 120086            LCALL    APL_Entry
   48: 
   49:         OS_SLEEP_MS(&vTCB_Idle, 50);
001A6F E50B              MOV      A,vTickCount+03H
001A71 2432              ADD      A,#032H
001A73 1230D8            LCALL    ?L?COM0024
001A76 900294            MOV      DPTR,#vEndTick
001A79 1202B2            LCALL    ?C?LSTXDATA
001A7C 750C00            MOV      vTCB_Idle,#00H
001A7F 750D31            MOV      vTCB_Idle+01H,#031H
001A82         ?C0012?THREAD_IDLE:
001A82 E4                CLR      A
001A83 F5FE              MOV      PCA0CPH4,A
001A85 900294            MOV      DPTR,#vEndTick
001A88 123013            LCALL    ?L?COM0009
001A8B 7F00              MOV      R7,#00H
001A8D 5002              JNC      ?C0014?THREAD_IDLE
001A8F 7F01              MOV      R7,#01H
001A91         ?C0014?THREAD_IDLE:
001A91         ?C0015?THREAD_IDLE:
001A91 EF                MOV      A,R7
001A92 60D5              JZ       ?C0004?THREAD_IDLE
001A94 7F00              MOV      R7,#00H
001A96 22                RET      
   50:     }
   51: 
   52:     PT_END(&vTCB_Idle);
001A97         ?C0002?THREAD_IDLE:
001A97 E4                CLR      A
001A98 F524              MOV      PT_YIELD_FLAG,A
001A9A F50C              MOV      vTCB_Idle,A
001A9C F50D              MOV      vTCB_Idle+01H,A
001A9E 7F03              MOV      R7,#03H
   53: }
001AA0 22                RET      
----- FUNCTION thread_IDLE_Entry (END) -------


----- FUNCTION thread_IDLE_Init (BEGIN) -----
 FILE: '..\plf\thread_idle.c'
   70: void thread_IDLE_Init(void)
   71: {
   72:     PT_INIT(&vTCB_Idle);
   73: 
001AA1 E4                CLR      A
001AA2 F50C              MOV      vTCB_Idle,A
001AA4 F50D              MOV      vTCB_Idle+01H,A
   74: 	/* system init */
   75:     CFG_Init();
   76:     DRV_Init();
001AA6 51F1              ACALL    DRV_Init
   77:     APL_Init();
001AA8 020086            LJMP     APL_Init
----- FUNCTION thread_IDLE_Init (END) -------


----- FUNCTION thread_LED_Entry (BEGIN) -----
 FILE: '..\plf\thread_led.c'
   37: OS_HANDLE thread_LED_Entry(void)
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 3


   38: {
   39:     PT_BEGIN(&vTCB_LED);
   40: 
001AAB 752401            MOV      PT_YIELD_FLAG,#01H
001AAE         ?C0001?THREAD_LED:
001AAE E50E              MOV      A,vTCB_LED
001AB0 7035              JNZ      ?C0002?THREAD_LED
001AB2 E50F              MOV      A,vTCB_LED+01H
001AB4 24C8              ADD      A,#0C8H
001AB6 601A              JZ       ?C0015?THREAD_LED
001AB8 2438              ADD      A,#038H
001ABA 702B              JNZ      ?C0002?THREAD_LED
   41:     for (;;)
   42:     {
   43:       #if CFG_SUPPORT
   44:         if (CFG_GET(RT_EVB_STAT_Global_Ready) == HIGH)
   45:         {
   46:             /* system running OK */
   47:             DRV_IO_Write(IO(IO_LED_STATUS_OUT), LOW);
   48:         }
   49:         else
   50:       #endif
   51:         {
001ABC         ?C0008?THREAD_LED:
   52:             /* system running abnormally */
   53:             DRV_IO_Toggle(IO(IO_LED_STATUS_OUT));
001ABC 63A008            XRL      P2,#08H
   54:         }
   55: 
   56:         OS_SLEEP_MS(&vTCB_LED, 100);
001ABF E50B              MOV      A,vTickCount+03H
001AC1 2464              ADD      A,#064H
001AC3 1230D8            LCALL    ?L?COM0024
001AC6 900298            MOV      DPTR,#vEndTick
001AC9 1202B2            LCALL    ?C?LSTXDATA
001ACC 750E00            MOV      vTCB_LED,#00H
001ACF 750F38            MOV      vTCB_LED+01H,#038H
001AD2         ?C0015?THREAD_LED:
001AD2 E4                CLR      A
001AD3 F5FE              MOV      PCA0CPH4,A
001AD5 900298            MOV      DPTR,#vEndTick
001AD8 123013            LCALL    ?L?COM0009
001ADB 7F00              MOV      R7,#00H
001ADD 5002              JNC      ?C0017?THREAD_LED
001ADF 7F01              MOV      R7,#01H
001AE1         ?C0017?THREAD_LED:
001AE1         ?C0018?THREAD_LED:
001AE1 EF                MOV      A,R7
001AE2 60D8              JZ       ?C0008?THREAD_LED
001AE4 7F00              MOV      R7,#00H
001AE6 22                RET      
   57:     }
   58: 
   59:     PT_END(&vTCB_LED);
001AE7         ?C0002?THREAD_LED:
001AE7 E4                CLR      A
001AE8 F524              MOV      PT_YIELD_FLAG,A
001AEA F50E              MOV      vTCB_LED,A
001AEC F50F              MOV      vTCB_LED+01H,A
001AEE 7F03              MOV      R7,#03H
   60: }
001AF0 22                RET      
----- FUNCTION thread_LED_Entry (END) -------


LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 4


----- FUNCTION DRV_Init (BEGIN) -----
 FILE: '..\drv\drv.c'
   56: void DRV_Init(void)
   57: {
   58: 	DRV_VECTOR_Init();
   59: 
   60:   #if DRV_FLASH_SUPPORT
   61: 	DRV_FLASH_Init();
   62:   #endif
   63: 
   64:   #if DRV_RESET_SUPPORT
   65: 	DRV_RESET_Init();
   66:   #endif
   67: 
   68:   #if DRV_TIMER_SUPPORT
   69: 	DRV_TIMER_Init();
001AF1 438E10            ORL      CKCON,#010H
001AF4 E4                CLR      A
001AF5 F5C8              MOV      TMR2CN,A
001AF7 75CA40            MOV      TMR2RLL,#040H
001AFA 75CC40            MOV      TMR2L,#040H
001AFD 75CBA2            MOV      TMR2RLH,#0A2H
001B00 75CDA2            MOV      TMR2H,#0A2H
001B03 C2CF              CLR      TF2H
001B05 D2CA              SETB     TR2
001B07 C2BD              CLR      PT2
001B09 D2AD              SETB     ET2
001B0B F50B              MOV      vTickCount+03H,A
001B0D F50A              MOV      vTickCount+02H,A
001B0F F509              MOV      vTickCount+01H,A
001B11 F508              MOV      vTickCount,A
   70:   #endif
   71: 
   72:   #if DRV_USB_SUPPORT
   73: 	DRV_USB_Init();
001B13 7120              ACALL    DRV_USB_Init
;----                  JMP      DRV_C2M_Init
   74:   #endif
   75: 
   76:   #if DRV_VREF_SUPPORT
   77: 	DRV_VREF_Init();
   78:   #endif
   79: 
   80:   #if DRV_ADC_SUPPORT
   81: 	DRV_ADC_Init();
   82:   #endif
   83: 
   84:   #if DRV_I2CM_SUPPORT
   85: 	DRV_I2CM_Init();
   86:   #endif
   87: 
   88:   #if DRV_C2M_SUPPORT
----- FUNCTION DRV_Init (END) -------


----- FUNCTION DRV_C2M_Init (BEGIN) -----
 FILE: '..\drv\drv_c2m.c'
  689: void DRV_C2M_Init(void)
  690: {
  691:     c2m_Init();
  692: }
001B15 53A57F            ANL      P1MDOUT,#07FH
001B18 53A6FE            ANL      P2MDOUT,#0FEH
001B1B D297              SETB     IO_C2M_SCL
001B1D D2A0              SETB     IO_C2M_SDA
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 5


  693: 
001B1F 22                RET      
----- FUNCTION DRV_C2M_Init (END) -------


----- FUNCTION DRV_USB_Init (BEGIN) -----
 FILE: '..\drv\drv_usb.c'
   44: void DRV_USB_Init(void)
   45: {
   46:     static SEG_CODE UINT8 aVN[DRV_USB_STRING_MAX_LEN+1] = DRV_USB_VendorName;
   47:     static SEG_CODE UINT8 aPN[DRV_USB_STRING_MAX_LEN+1] = DRV_USB_PartNumber;
   48:     static SEG_CODE UINT8 aSN[DRV_USB_STRING_MAX_LEN+1] = DRV_USB_SerialNumber;
   49:     UINT8   vData;
   50:     UINT8   vLoop;
   51: 
   52:     /* init USB manufacture string */
   53:     aManufacturerStr[1] = 0x03;
001B20 90022F            MOV      DPTR,#aManufacturerStr+01H
001B23 7403              MOV      A,#03H
001B25 F0                MOVX     @DPTR,A
   54:     for (vLoop=2; vLoop<sizeof(aManufacturerStr); vLoop+=2)
;---- Variable 'vLoop' assigned to Register 'R7' ----
001B26 7F02              MOV      R7,#02H
001B28         ?C0001?DRV_USB:
001B28 EF                MOV      A,R7
001B29 C3                CLR      C
001B2A 9422              SUBB     A,#022H
001B2C 502B              JNC      ?C0002?DRV_USB
   55:     {
   56:         vData = aVN[(vLoop>>1)-1];
001B2E EF                MOV      A,R7
001B2F C3                CLR      C
001B30 13                RRC      A
001B31 901A12            MOV      DPTR,#aVN-01H
001B34 1231BC            LCALL    ?L?COM0046
001B37 4020              JC       ?C0002?DRV_USB
001B39 E524              MOV      A,vData
001B3B 947F              SUBB     A,#07FH
001B3D 501A              JNC      ?C0002?DRV_USB
   57: 
   58:         if ((vData < 0x20) || (vData >= 0x7F))
   59:         {
   60:             break;
   61:         }
001B3F         ?C0004?DRV_USB:
   62: 
   63:         aManufacturerStr[vLoop+0] = vData;
001B3F 742E              MOV      A,#LOW aManufacturerStr
001B41 2F                ADD      A,R7
001B42 F582              MOV      DPL,A
001B44 E4                CLR      A
001B45 3402              ADDC     A,#HIGH aManufacturerStr
001B47 F583              MOV      DPH,A
001B49 E524              MOV      A,vData
001B4B F0                MOVX     @DPTR,A
   64:         aManufacturerStr[vLoop+1] = 0;
001B4C 742F              MOV      A,#LOW aManufacturerStr+01H
001B4E 2F                ADD      A,R7
001B4F F582              MOV      DPL,A
001B51 E4                CLR      A
001B52 3402              ADDC     A,#HIGH aManufacturerStr+01H
001B54 1231B5            LCALL    ?L?COM0045
001B57 80CF              SJMP     ?C0001?DRV_USB
001B59         ?C0002?DRV_USB:
   65:     }
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 6


   66:     aManufacturerStr[0] = vLoop;
001B59 90022E            MOV      DPTR,#aManufacturerStr
001B5C EF                MOV      A,R7
001B5D F0                MOVX     @DPTR,A
   67: 
   68:     /* init USB product string */
   69:     aProductStr[1] = 0x03;
001B5E 900251            MOV      DPTR,#aProductStr+01H
001B61 7403              MOV      A,#03H
001B63 F0                MOVX     @DPTR,A
   70:     for (vLoop=2; vLoop<sizeof(aProductStr); vLoop+=2)
001B64 7F02              MOV      R7,#02H
001B66         ?C0006?DRV_USB:
001B66 EF                MOV      A,R7
001B67 C3                CLR      C
001B68 9422              SUBB     A,#022H
001B6A 502B              JNC      ?C0007?DRV_USB
   71:     {
   72:         vData = aPN[(vLoop>>1)-1];
001B6C EF                MOV      A,R7
001B6D C3                CLR      C
001B6E 13                RRC      A
001B6F 901A23            MOV      DPTR,#aPN-01H
001B72 1231BC            LCALL    ?L?COM0046
001B75 4020              JC       ?C0007?DRV_USB
001B77 E524              MOV      A,vData
001B79 947F              SUBB     A,#07FH
001B7B 501A              JNC      ?C0007?DRV_USB
   73: 
   74:         if ((vData < 0x20) || (vData >= 0x7F))
   75:         {
   76:             break;
   77:         }
001B7D         ?C0009?DRV_USB:
   78: 
   79:         aProductStr[vLoop+0] = vData;
001B7D 7450              MOV      A,#LOW aProductStr
001B7F 2F                ADD      A,R7
001B80 F582              MOV      DPL,A
001B82 E4                CLR      A
001B83 3402              ADDC     A,#HIGH aProductStr
001B85 F583              MOV      DPH,A
001B87 E524              MOV      A,vData
001B89 F0                MOVX     @DPTR,A
   80:         aProductStr[vLoop+1] = 0;
001B8A 7451              MOV      A,#LOW aProductStr+01H
001B8C 2F                ADD      A,R7
001B8D F582              MOV      DPL,A
001B8F E4                CLR      A
001B90 3402              ADDC     A,#HIGH aProductStr+01H
001B92 1231B5            LCALL    ?L?COM0045
001B95 80CF              SJMP     ?C0006?DRV_USB
001B97         ?C0007?DRV_USB:
   81:     }
   82:     aProductStr[0] = vLoop;
001B97 900250            MOV      DPTR,#aProductStr
001B9A EF                MOV      A,R7
001B9B F0                MOVX     @DPTR,A
   83: 
   84:     /* init USB serial number string */
   85:     aSerialNumberStr[1] = 0x03;
001B9C 900273            MOV      DPTR,#aSerialNumberStr+01H
001B9F 7403              MOV      A,#03H
001BA1 F0                MOVX     @DPTR,A
   86:     for (vLoop=2; vLoop<sizeof(aSerialNumberStr); vLoop+=2)
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 7


001BA2 7F02              MOV      R7,#02H
001BA4         ?C0011?DRV_USB:
001BA4 EF                MOV      A,R7
001BA5 C3                CLR      C
001BA6 9422              SUBB     A,#022H
001BA8 502B              JNC      ?C0012?DRV_USB
   87:     {
   88:         vData = aSN[(vLoop>>1)-1];
001BAA EF                MOV      A,R7
001BAB C3                CLR      C
001BAC 13                RRC      A
001BAD 901A34            MOV      DPTR,#aSN-01H
001BB0 1231BC            LCALL    ?L?COM0046
001BB3 4020              JC       ?C0012?DRV_USB
001BB5 E524              MOV      A,vData
001BB7 947F              SUBB     A,#07FH
001BB9 501A              JNC      ?C0012?DRV_USB
   89: 
   90:         if ((vData < 0x20) || (vData >= 0x7F))
   91:         {
   92:             break;
   93:         }
001BBB         ?C0014?DRV_USB:
   94: 
   95:         aSerialNumberStr[vLoop+0] = vData;
001BBB 7472              MOV      A,#LOW aSerialNumberStr
001BBD 2F                ADD      A,R7
001BBE F582              MOV      DPL,A
001BC0 E4                CLR      A
001BC1 3402              ADDC     A,#HIGH aSerialNumberStr
001BC3 F583              MOV      DPH,A
001BC5 E524              MOV      A,vData
001BC7 F0                MOVX     @DPTR,A
   96:         aSerialNumberStr[vLoop+1] = 0;
001BC8 7473              MOV      A,#LOW aSerialNumberStr+01H
001BCA 2F                ADD      A,R7
001BCB F582              MOV      DPL,A
001BCD E4                CLR      A
001BCE 3402              ADDC     A,#HIGH aSerialNumberStr+01H
001BD0 1231B5            LCALL    ?L?COM0045
001BD3 80CF              SJMP     ?C0011?DRV_USB
001BD5         ?C0012?DRV_USB:
   97:     }
   98:     aSerialNumberStr[0] = vLoop;
001BD5 900272            MOV      DPTR,#aSerialNumberStr
001BD8 EF                MOV      A,R7
001BD9 F0                MOVX     @DPTR,A
   99: 
  100:     /* set USB0 to the high priority level interrupt */
  101:     EIP1 |= (1<<1);
001BDA 43F602            ORL      EIP1,#02H
  102: 
  103:     /* init USB device */
  104:     USB_Clock_Start();
001BDD 120046            LCALL    USB_Clock_Start
  105:     USB_Init(DRV_USB_VID,
001BE0 9001B4            MOV      DPTR,#?_USB_Init?BYTE+07H
001BE3 7401              MOV      A,#01H
001BE5 F0                MOVX     @DPTR,A
001BE6 A3                INC      DPTR
001BE7 7402              MOV      A,#HIGH aProductStr
001BE9 F0                MOVX     @DPTR,A
001BEA A3                INC      DPTR
001BEB 7450              MOV      A,#LOW aProductStr
001BED F0                MOVX     @DPTR,A
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 8


001BEE A3                INC      DPTR
001BEF 7401              MOV      A,#01H
001BF1 F0                MOVX     @DPTR,A
001BF2 A3                INC      DPTR
001BF3 7402              MOV      A,#HIGH aSerialNumberStr
001BF5 F0                MOVX     @DPTR,A
001BF6 A3                INC      DPTR
001BF7 7472              MOV      A,#LOW aSerialNumberStr
001BF9 F0                MOVX     @DPTR,A
001BFA A3                INC      DPTR
001BFB 74FA              MOV      A,#0FAH
001BFD F0                MOVX     @DPTR,A
001BFE A3                INC      DPTR
001BFF 7480              MOV      A,#080H
001C01 F0                MOVX     @DPTR,A
001C02 A3                INC      DPTR
001C03 7401              MOV      A,#01H
001C05 F0                MOVX     @DPTR,A
001C06 A3                INC      DPTR
001C07 E4                CLR      A
001C08 F0                MOVX     @DPTR,A
001C09 7B01              MOV      R3,#01H
001C0B 7A02              MOV      R2,#HIGH aManufacturerStr
001C0D 792E              MOV      R1,#LOW aManufacturerStr
001C0F 7D61              MOV      R5,#061H
001C11 7CEA              MOV      R4,#0EAH
001C13 7FC4              MOV      R7,#0C4H
001C15 7E10              MOV      R6,#010H
001C17 1211A2            LCALL    _USB_Init
  106:              DRV_USB_PID,
  107:              aManufacturerStr,
  108:              aProductStr,
  109:              aSerialNumberStr,
  110:              0xFA,      /* maximum current: 500mA */
  111:              0x80,      /* bus-powered, remote wakeup is unsupported */
  112:              0x100);    /* device release number 1.00 */
  113: 
  114:     /* the USB_Init() API will auto-enable global interrupt,
  115:      * disable it here, and will be enabled later.
  116:      */
  117:     DRV_INT_GlobalDisableInterrupt();
001C1A C2AF              CLR      EA
  118: }
001C1C 22                RET      
----- FUNCTION DRV_USB_Init (END) -------


----- FUNCTION thread_LED_Init (BEGIN) -----
 FILE: '..\plf\thread_led.c'
   77: void thread_LED_Init(void)
   78: {
   79:     PT_INIT(&vTCB_LED);
   80: }
001C1D E4                CLR      A
001C1E F50E              MOV      vTCB_LED,A
001C20 F50F              MOV      vTCB_LED+01H,A
   81: 
001C22 22                RET      
----- FUNCTION thread_LED_Init (END) -------


----- FUNCTION _fixupInit (BEGIN) -----
 FILE: '..\plf\main.c'
   35: static void _fixupInit(void)
   36: {
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 9


   37:     /* Globally enable Interrupt */
   38:     DRV_INT_GlobalEnableInterrupt();
001C23 D2AF              SETB     EA
   39: 
   40:   #if DRV_USB_SUPPORT
   41: 	/* enable USB interface */
   42: 	DRV_USB_Enable();
001C25 21DA              AJMP     USB_Int_Enable
----- FUNCTION _fixupInit (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: '..\plf\main.c'
   61: void main(void)
   62: {
   63: 	/* previous init */
   64: 	DRV_PreInit();
001C27 915E              ACALL    DRV_PreInit
   65: 
   66:     /* init protothread */
   67:     OS_Init();
001C29 9146              ACALL    OS_Init
   68: 
   69:     /* fixup init */
   70:     _fixupInit();
001C2B 9123              ACALL    _fixupInit
;----                  JMP      OS_Start
   71: 
   72:     /* start protothread (never return) */
----- FUNCTION main (END) -------


----- FUNCTION OS_Start (BEGIN) -----
 FILE: '..\os\os.c'
   48: void OS_Start(void)
   49: {
   50:     for (;;)
   51:     {
001C2D         ?C0001?OS:
   52:         UINT8   i;
   53: 
   54:         for (i = 0; i < COUNT_OF(aThreadList); i++)
001C2D E4                CLR      A
001C2E F523              MOV      i,A
001C30         ?C0003?OS:
   55:         {
   56:             aThreadList[i].pEntry();
001C30 E523              MOV      A,i
001C32 75F006            MOV      B,#06H
001C35 A4                MUL      AB
001C36 2446              ADD      A,#LOW aThreadList
001C38 F582              MOV      DPL,A
001C3A E4                CLR      A
001C3B 341A              ADDC     A,#HIGH aThreadList
001C3D 12311B            LCALL    ?L?COM002F
001C40 9403              SUBB     A,#03H
001C42 40EC              JC       ?C0003?OS
001C44 80E7              SJMP     ?C0001?OS
   57:         }
----- FUNCTION OS_Start (END) -------


----- FUNCTION OS_Init (BEGIN) -----
 FILE: '..\os\os.c'
   76: void OS_Init(void)
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 10


   77: {
   78:     UINT8   i;
   79: 
   80:     for (i = 0; i < COUNT_OF(aThreadList); i++)
001C46 E4                CLR      A
001C47 F523              MOV      i,A
001C49         ?C0007?OS:
   81:     {
   82:         aThreadList[i].pInit();
001C49 E523              MOV      A,i
001C4B 75F006            MOV      B,#06H
001C4E A4                MUL      AB
001C4F 2449              ADD      A,#LOW aThreadList+03H
001C51 F582              MOV      DPL,A
001C53 E4                CLR      A
001C54 341A              ADDC     A,#HIGH aThreadList+03H
001C56 12311B            LCALL    ?L?COM002F
001C59 9403              SUBB     A,#03H
001C5B 40EC              JC       ?C0007?OS
   83:     }
   84: }
001C5D 22                RET      
----- FUNCTION OS_Init (END) -------


----- FUNCTION DRV_PreInit (BEGIN) -----
 FILE: '..\drv\drv.c'
  108: void DRV_PreInit(void)
  109: {
  110:     /* disable all interrupt */
  111:     DRV_INT_DisableAllInterrupt();
001C5E E4                CLR      A
001C5F F5A8              MOV      IE,A
001C61 F5E6              MOV      EIE1,A
  112: 
  113:   #if DRV_CLOCK_SUPPORT
  114:     DRV_CLOCK_Init();
001C63 75B283            MOV      OSCICN,#083H
001C66         ?C0024?DRV:
001C66 E5B2              MOV      A,OSCICN
001C68 C4                SWAP     A
001C69 13                RRC      A
001C6A 13                RRC      A
001C6B 5403              ANL      A,#03H
001C6D 13                RRC      A
001C6E 50F6              JNC      ?C0024?DRV
001C70         ?C0025?DRV:
001C70 75B980            MOV      CLKMUL,#080H
001C73 7F05              MOV      R7,#05H
001C75 7E00              MOV      R6,#00H
001C77 91E0              ACALL    _DRV_CPU_DelayUs
001C79 43B9C0            ORL      CLKMUL,#0C0H
001C7C         ?C0026?DRV:
001C7C E5B9              MOV      A,CLKMUL
001C7E C4                SWAP     A
001C7F 13                RRC      A
001C80 5407              ANL      A,#07H
001C82 13                RRC      A
001C83 50F7              JNC      ?C0026?DRV
001C85         ?C0027?DRV:
001C85 75A902            MOV      CLKSEL,#02H
001C88 75B680            MOV      FLSCL,#080H
  115:   #endif
  116: 
  117:   #if DRV_IO_SUPPORT
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 11


  118: 	DRV_IO_Init();
001C8B 122800            LCALL    DRV_IO_Init
  119:   #endif
  120: 
  121:   #if DRV_UART_SUPPORT
  122:     DRV_UART_Init();
001C8E 438E08            ORL      CKCON,#08H
001C91 E589              MOV      A,TMOD
001C93 540F              ANL      A,#0FH
001C95 4420              ORL      A,#020H
001C97 F589              MOV      TMOD,A
001C99 758D98            MOV      TH1,#098H
001C9C D28E              SETB     TR1
001C9E AFD4              MOV      R7,P0SKIP
001CA0 EF                MOV      A,R7
001CA1 54EF              ANL      A,#0EFH
001CA3 FF                MOV      R7,A
001CA4 8FD4              MOV      P0SKIP,R7
001CA6 AFD4              MOV      R7,P0SKIP
001CA8 EF                MOV      A,R7
001CA9 54DF              ANL      A,#0DFH
001CAB FF                MOV      R7,A
001CAC 8FD4              MOV      P0SKIP,R7
001CAE 43E101            ORL      XBR0,#01H
001CB1 759812            MOV      SCON0,#012H
  123:   #endif
  124: 
  125:   #if DRV_PCA_SUPPORT
  126:     DRV_PCA_Init();
001CB4 122833            LCALL    DRV_PCA_Init
  127:   #endif
  128: 
  129:   #if DRV_WATCHDOG_SUPPORT
  130: 	DRV_WATCHDOG_Enable();
001CB7 E58E              MOV      A,CKCON
001CB9 54F8              ANL      A,#0F8H
001CBB 4402              ORL      A,#02H
001CBD F58E              MOV      CKCON,A
001CBF E589              MOV      A,TMOD
001CC1 54F0              ANL      A,#0F0H
001CC3 4402              ORL      A,#02H
001CC5 F589              MOV      TMOD,A
001CC7 758CCE            MOV      TH0,#0CEH
001CCA D28C              SETB     TR0
001CCC 75FD75            MOV      PCA0CPL4,#075H
001CCF 43D940            ORL      PCA0MD,#040H
001CD2 E4                CLR      A
001CD3 F5FE              MOV      PCA0CPH4,A
  131:   #endif
  132: }
001CD5 22                RET      
----- FUNCTION DRV_PreInit (END) -------


----- FUNCTION ?L?COM0006 (BEGIN) -----
001CD6 A2A0              MOV      C,IO_C2M_SDA
001CD8 D297              SETB     IO_C2M_SCL
001CDA 9200              MOV      bC2Bit0,C
001CDC         ?L?COM0007:
001CDC 7F01              MOV      R7,#01H
001CDE 7E00              MOV      R6,#00H
----- FUNCTION _DRV_CPU_DelayUs (BEGIN) -----
 FILE: '..\drv\drv_cpu.c'
   35: void DRV_CPU_DelayUs(UINT16 vUsec)
   36: {
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 12


;---- Variable 'vUsec' assigned to Register 'R6/R7' ----
   37:     NOP(); NOP(); NOP();
   38: 
001CE0 8018              SJMP     ?C0013?DRV_CPU
001CE2         ?C0001?DRV_CPU:
   39:     while (--vUsec)
001CE2 EF                MOV      A,R7
001CE3 1F                DEC      R7
001CE4 7001              JNZ      ?C0011?DRV_CPU
001CE6 1E                DEC      R6
001CE7         ?C0011?DRV_CPU:
001CE7 14                DEC      A
001CE8 4E                ORL      A,R6
001CE9 6014              JZ       ?C0003?DRV_CPU
   40:     {
   41:       #if (CORE_CLOCK == 24000000UL)
   42: 		NOP(); NOP(); NOP(); NOP(); NOP();
001CEB 00                NOP      
001CEC 00                NOP      
001CED 00                NOP      
001CEE 00                NOP      
001CEF 00                NOP      
   43: 		NOP(); NOP(); NOP(); NOP(); NOP();
001CF0 00                NOP      
001CF1 00                NOP      
001CF2 00                NOP      
001CF3 00                NOP      
001CF4 00                NOP      
   44: 		NOP(); NOP(); NOP(); NOP(); NOP();
001CF5 00                NOP      
001CF6 00                NOP      
001CF7 00                NOP      
001CF8 00                NOP      
001CF9 00                NOP      
   45: 		NOP(); NOP(); NOP();
001CFA         
001CFA 00                NOP      
001CFB 00                NOP      
001CFC 00                NOP      
   46:       #else
   47:         #error "Unsupported Core Clock!"
   48:       #endif
   49:     }
001CFD 80E3              SJMP     ?C0001?DRV_CPU
   50: }
001CFF         ?C0003?DRV_CPU:
001CFF 22                RET      
----- FUNCTION _DRV_CPU_DelayUs (END) -------


----- FUNCTION DRV_C2M_Probe (BEGIN) -----
 FILE: '..\drv\drv_c2m.c'
  443: UINT32 DRV_C2M_Probe(void)
  444: {
  445:     UU32    vDevice;
  446: 
  447:     vDevice.U32 = 0xFFFFFFFFUL;
001D00 74FF              MOV      A,#0FFH
001D02 F52B              MOV      vDevice+03H,A
001D04 F52A              MOV      vDevice+02H,A
001D06 F529              MOV      vDevice+01H,A
001D08 F528              MOV      vDevice,A
  448: 
  449:     if (!drv_c2m_IsReady())
001D0A 209702            JB       IO_C2M_SCL,$ + 5H
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 13


001D0D A198              AJMP     _exit?DRV_C2M
001D0F 20A002            JB       IO_C2M_SDA,$ + 5H
001D12 A198              AJMP     _exit?DRV_C2M
  450:     {
  451:         /* C2 bus is not ready */
  452:         goto _exit;
  453:     }
  454: 
  455:     drv_c2m_Init();
001D14         ?C0852?DRV_C2M:
001D14 1230BF            LCALL    ?L?COM0022
001D17 7F02              MOV      R7,#02H
001D19 12214E            LCALL    _c2m_WriteAR
001D1C 12286D            LCALL    _c2m_WriteDR
001D1F 7F04              MOV      R7,#04H
001D21 12286D            LCALL    _c2m_WriteDR
001D24 7F01              MOV      R7,#01H
001D26 12286D            LCALL    _c2m_WriteDR
001D29 7F14              MOV      R7,#014H
001D2B 7E00              MOV      R6,#00H
001D2D 1221C2            LCALL    _DRV_CPU_DelayMs
  456: 
  457:     /* get C2 device id & revision id */
  458:     vDevice.U8[0] = drv_c2m_ReadSFR(C2_DEVICEID);
001D30 E4                CLR      A
001D31 FF                MOV      R7,A
001D32 F1E3              ACALL    _drv_c2m_ReadSFR
001D34 8F28              MOV      vDevice,R7
  459:     vDevice.U8[1] = drv_c2m_ReadSFR(C2_REVID);
001D36 7F01              MOV      R7,#01H
001D38 F1E3              ACALL    _drv_c2m_ReadSFR
001D3A 8F29              MOV      vDevice+01H,R7
  460: 
  461:     if (vDevice.U8[0] == 0xFF)
001D3C E528              MOV      A,vDevice
001D3E F4                CPL      A
001D3F 6057              JZ       _exit?DRV_C2M
  462:     {
  463:         /* no device probed */
  464:         goto _exit;
  465:     }
001D41         ?C0862?DRV_C2M:
  466: 
  467:     /* get C2 device derivative id */
  468:     vFPDAT = C2_FPDAT;
001D41 7514B4            MOV      vFPDAT,#0B4H
  469:     c2m_WriteAR(vFPDAT);
001D44 123225            LCALL    ?L?COM0052
001D47 B1A1              ACALL    _drv_c2m_WriteData
  470:     drv_c2m_WriteData(C2_FPDAT_GET_DERIVATIVE);
  471:     if (drv_c2m_ReadData() != C2_COMMAND_OK)
001D49 F1C5              ACALL    drv_c2m_ReadData
001D4B EF                MOV      A,R7
001D4C 640D              XRL      A,#0DH
001D4E 601F              JZ       ?C0863?DRV_C2M
  472:     {
  473:         /* the FPDAT address may be incorrect, try another FPDAT address */
  474:         vFPDAT = C2_FPDAT2;
001D50 7514AD            MOV      vFPDAT,#0ADH
  475:         c2m_WriteAR(vFPDAT);
001D53 123225            LCALL    ?L?COM0052
001D56 123166            LCALL    ?L?COM003A
001D59         ?C0870?DRV_C2M:
001D59 D1D3              ACALL    c2m_ReadAR
001D5B EF                MOV      A,R7
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 14


001D5C 20E00B            JB       ACC.0,?C0868?DRV_C2M
001D5F 782C              MOV      R0,#LOW _timeout
001D61 122FFC            LCALL    ?L?COM0005
001D64 6004              JZ       ?C0868?DRV_C2M
001D66 91DC              ACALL    ?L?COM0007
001D68 80EF              SJMP     ?C0870?DRV_C2M
001D6A         ?C0868?DRV_C2M:
001D6A 12310C            LCALL    ?L?COM002A
001D6D 7029              JNZ      _exit?DRV_C2M
001D6F         ?C0872?DRV_C2M:
  476:         drv_c2m_WriteData(C2_FPDAT_GET_DERIVATIVE);
  477:         drv_c2m_CheckResponse(C2_TIMEOUT_VAL);
  478:     }
001D6F         ?C0863?DRV_C2M:
  479:     vDevice.U8[2] = drv_c2m_ReadData();
001D6F F1C5              ACALL    drv_c2m_ReadData
001D71 8F2A              MOV      vDevice+02H,R7
  480: 
  481:     /* get C2 device derivative version */
  482:     c2m_WriteAR(vFPDAT);
001D73 AF14              MOV      R7,vFPDAT
001D75 12214E            LCALL    _c2m_WriteAR
  483:     drv_c2m_WriteData(C2_FPDAT_GET_VERSION);
001D78 7F01              MOV      R7,#01H
001D7A 123166            LCALL    ?L?COM003A
001D7D         ?C0879?DRV_C2M:
001D7D D1D3              ACALL    c2m_ReadAR
001D7F EF                MOV      A,R7
001D80 20E00B            JB       ACC.0,?C0877?DRV_C2M
001D83 782C              MOV      R0,#LOW _timeout
001D85 122FFC            LCALL    ?L?COM0005
001D88 6004              JZ       ?C0877?DRV_C2M
001D8A 91DC              ACALL    ?L?COM0007
001D8C 80EF              SJMP     ?C0879?DRV_C2M
001D8E         ?C0877?DRV_C2M:
001D8E 122000            LCALL    c2m_ReadDR
001D91 BF0D04            CJNE     R7,#0DH,_exit?DRV_C2M
001D94         ?C0881?DRV_C2M:
001D94         ?C0874?DRV_C2M:
  484:     drv_c2m_CheckResponse(C2_TIMEOUT_VAL);
  485:     vDevice.U8[3] = drv_c2m_ReadData();
001D94 F1C5              ACALL    drv_c2m_ReadData
001D96 8F2B              MOV      vDevice+03H,R7
  486: 
  487: _exit:
001D98         _exit:
  488:     return vDevice.U32;
001D98 AF2B              MOV      R7,vDevice+03H
001D9A AE2A              MOV      R6,vDevice+02H
001D9C AD29              MOV      R5,vDevice+01H
001D9E AC28              MOV      R4,vDevice
  489: }
001DA0 22                RET      
----- FUNCTION DRV_C2M_Probe (END) -------


----- FUNCTION _drv_c2m_WriteData (BEGIN) -----
 FILE: '..\drv\drv_c2m.c'
  357: static void drv_c2m_WriteData(UINT8 vCmd)
  358: {
;---- Variable 'vCmd' assigned to Register 'R7' ----
  359:     c2m_WriteDR(vCmd);
  360:     drv_c2m_PollInBusy(C2_TIMEOUT_VAL);
001DA1 12286D            LCALL    _c2m_WriteDR
  361: }
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 15


001DA4 753627            MOV      _timeout,#027H
001DA7 753710            MOV      _timeout+01H,#010H
001DAA         ?C0788?DRV_C2M:
001DAA D1D3              ACALL    c2m_ReadAR
001DAC EF                MOV      A,R7
001DAD 30E111            JNB      ACC.1,?C0790?DRV_C2M
001DB0 E537              MOV      A,_timeout+01H
001DB2 1537              DEC      _timeout+01H
001DB4 AE36              MOV      R6,_timeout
001DB6 7002              JNZ      ?C1015?DRV_C2M
001DB8 1536              DEC      _timeout
001DBA         ?C1015?DRV_C2M:
001DBA 4E                ORL      A,R6
001DBB 6004              JZ       ?C0790?DRV_C2M
001DBD 91DC              ACALL    ?L?COM0007
001DBF 80E9              SJMP     ?C0788?DRV_C2M
  362: 
001DC1         ?C0790?DRV_C2M:
001DC1 22                RET      
----- FUNCTION _drv_c2m_WriteData (END) -------


----- FUNCTION _DRV_C2M_FlashWrite (BEGIN) -----
 FILE: '..\drv\drv_c2m.c'
  639: BOOL DRV_C2M_FlashWrite
  640: (
001DC2 8E2B              MOV      vAddr,R6
001DC4 8F2C              MOV      vAddr+01H,R7
001DC6 8C2D              MOV      pBuf,R4
001DC8 8D2E              MOV      pBuf+01H,R5
;---- Variable 'vCount' assigned to Register 'R3' ----
  641:     IN       UINT16           vAddr,
  642:     IN const UINT8 SEG_XDATA *pBuf,
  643:     IN       UINT8            vCount
  644: )
  645: {
  646:     UINT16  vLen = ((vCount==0)?256:vCount);
001DCA EB                MOV      A,R3
001DCB 7005              JNZ      ?C0962?DRV_C2M
001DCD 7E01              MOV      R6,#01H
001DCF FF                MOV      R7,A
001DD0 8004              SJMP     ?C0963?DRV_C2M
001DD2         ?C0962?DRV_C2M:
001DD2 EB                MOV      A,R3
001DD3 FF                MOV      R7,A
001DD4 7E00              MOV      R6,#00H
001DD6         ?C0963?DRV_C2M:
001DD6 8E2F              MOV      vLen,R6
001DD8 8F30              MOV      vLen+01H,R7
  647:     BOOL    bDone = FALSE;
001DDA C208              CLR      bDone
  648: 
  649:     if (!drv_c2m_IsReady())
001DDC 209702            JB       IO_C2M_SCL,$ + 5H
001DDF C160              AJMP     _exit?DRV_C2M
001DE1 30A07C            JNB      IO_C2M_SDA,_exit?DRV_C2M
  650:     {
  651:         /* C2 bus is not ready */
  652:         goto _exit;
  653:     }
001DE4         ?C0964?DRV_C2M:
  654: 
  655:     c2m_WriteAR(vFPDAT);
001DE4 AF14              MOV      R7,vFPDAT
001DE6 12214E            LCALL    _c2m_WriteAR
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 16


  656:     drv_c2m_WriteData(C2_FPDAT_BLOCK_WRITE);
001DE9 7F07              MOV      R7,#07H
001DEB 1230FD            LCALL    ?L?COM0026
001DEE         ?C0973?DRV_C2M:
001DEE D1D3              ACALL    c2m_ReadAR
001DF0 EF                MOV      A,R7
001DF1 20E009            JB       ACC.0,?C0971?DRV_C2M
001DF4 122FFA            LCALL    ?L?COM0004
001DF7 6004              JZ       ?C0971?DRV_C2M
001DF9 91DC              ACALL    ?L?COM0007
001DFB 80F1              SJMP     ?C0973?DRV_C2M
001DFD         ?C0971?DRV_C2M:
001DFD 12310C            LCALL    ?L?COM002A
001E00 705E              JNZ      _exit?DRV_C2M
001E02         ?C0975?DRV_C2M:
001E02         ?C0968?DRV_C2M:
  657:     drv_c2m_CheckResponse(C2_TIMEOUT_VAL);
  658:     drv_c2m_WriteData(vAddr>>8);    /* MSB of address */
001E02 E52B              MOV      A,vAddr
001E04 FF                MOV      R7,A
001E05 B1A1              ACALL    _drv_c2m_WriteData
  659:     drv_c2m_WriteData(vAddr&0xFF);  /* LSB of address */
001E07 AF2C              MOV      R7,vAddr+01H
001E09 B1A1              ACALL    _drv_c2m_WriteData
  660:     drv_c2m_WriteData(vCount);      /* write length   */
001E0B AF03              MOV      R7,AR3
001E0D 1230FD            LCALL    ?L?COM0026
001E10         ?C0982?DRV_C2M:
001E10 D1D3              ACALL    c2m_ReadAR
001E12 EF                MOV      A,R7
001E13 20E009            JB       ACC.0,?C0980?DRV_C2M
001E16 122FFA            LCALL    ?L?COM0004
001E19 6004              JZ       ?C0980?DRV_C2M
001E1B 91DC              ACALL    ?L?COM0007
001E1D 80F1              SJMP     ?C0982?DRV_C2M
001E1F         ?C0980?DRV_C2M:
001E1F 12310C            LCALL    ?L?COM002A
001E22 703C              JNZ      _exit?DRV_C2M
001E24         ?C0984?DRV_C2M:
001E24         ?C0985?DRV_C2M:
  661:     drv_c2m_CheckResponse(C2_TIMEOUT_VAL);
  662:     while (vLen--)
001E24 E530              MOV      A,vLen+01H
001E26 1530              DEC      vLen+01H
001E28 AE2F              MOV      R6,vLen
001E2A 7002              JNZ      ?C1018?DRV_C2M
001E2C 152F              DEC      vLen
001E2E         ?C1018?DRV_C2M:
001E2E 4E                ORL      A,R6
001E2F 6015              JZ       ?C0992?DRV_C2M
  663:     {
  664:         /* write data into flash */
  665:         drv_c2m_WriteData(*pBuf++);
001E31 052E              INC      pBuf+01H
001E33 E52E              MOV      A,pBuf+01H
001E35 AE2D              MOV      R6,pBuf
001E37 7002              JNZ      ?C1019?DRV_C2M
001E39 052D              INC      pBuf
001E3B         ?C1019?DRV_C2M:
001E3B 14                DEC      A
001E3C F582              MOV      DPL,A
001E3E 8E83              MOV      DPH,R6
001E40 E0                MOVX     A,@DPTR
001E41 FF                MOV      R7,A
001E42 B1A1              ACALL    _drv_c2m_WriteData
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 17


  666:     }
001E44 80DE              SJMP     ?C0985?DRV_C2M
  667:     drv_c2m_CheckResponse(C2_TIMEOUT_VAL);
001E46         ?C0992?DRV_C2M:
001E46 123100            LCALL    ?L?COM0027
001E49         ?C0993?DRV_C2M:
001E49 D1D3              ACALL    c2m_ReadAR
001E4B EF                MOV      A,R7
001E4C 20E009            JB       ACC.0,?C0991?DRV_C2M
001E4F 122FFA            LCALL    ?L?COM0004
001E52 6004              JZ       ?C0991?DRV_C2M
001E54 91DC              ACALL    ?L?COM0007
001E56 80F1              SJMP     ?C0993?DRV_C2M
001E58         ?C0991?DRV_C2M:
001E58 122000            LCALL    c2m_ReadDR
001E5B BF0D02            CJNE     R7,#0DH,_exit?DRV_C2M
001E5E         ?C0995?DRV_C2M:
001E5E         ?C0988?DRV_C2M:
  668:     bDone = TRUE;
001E5E D208              SETB     bDone
  669: 
  670: _exit:
001E60         _exit:
  671:     return bDone;
001E60 A208              MOV      C,bDone
  672: }
001E62 22                RET      
----- FUNCTION _DRV_C2M_FlashWrite (END) -------


----- FUNCTION _DRV_C2M_PageErase (BEGIN) -----
 FILE: '..\drv\drv_c2m.c'
  546: BOOL DRV_C2M_PageErase(UINT8 vPageNo)
  547: {
;---- Variable 'vPageNo' assigned to Register 'R3' ----
001E63 AB07              MOV      R3,AR7
  548:     BOOL    bDone = FALSE;
  549: 
001E65 C208              CLR      bDone
  550:     if (!drv_c2m_IsReady())
001E67 309766            JNB      IO_C2M_SCL,_exit?DRV_C2M
001E6A 30A063            JNB      IO_C2M_SDA,_exit?DRV_C2M
  551:     {
  552:         /* C2 bus is not ready */
  553:         goto _exit;
  554:     }
001E6D         ?C0905?DRV_C2M:
  555: 
  556:     c2m_WriteAR(vFPDAT);
001E6D AF14              MOV      R7,vFPDAT
001E6F 12214E            LCALL    _c2m_WriteAR
  557:     drv_c2m_WriteData(C2_FPDAT_PAGE_ERASE);
001E72 7F08              MOV      R7,#08H
001E74 123157            LCALL    ?L?COM0039
001E77         ?C0914?DRV_C2M:
001E77 D1D3              ACALL    c2m_ReadAR
001E79 EF                MOV      A,R7
001E7A 20E00B            JB       ACC.0,?C0912?DRV_C2M
001E7D 7829              MOV      R0,#LOW _timeout
001E7F 122FFC            LCALL    ?L?COM0005
001E82 6004              JZ       ?C0912?DRV_C2M
001E84 91DC              ACALL    ?L?COM0007
001E86 80EF              SJMP     ?C0914?DRV_C2M
001E88         ?C0912?DRV_C2M:
001E88 12310C            LCALL    ?L?COM002A
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 18


001E8B 7043              JNZ      _exit?DRV_C2M
001E8D         ?C0916?DRV_C2M:
001E8D         ?C0909?DRV_C2M:
  558:     drv_c2m_CheckResponse(C2_TIMEOUT_VAL);
  559:     drv_c2m_WriteData(vPageNo); /* send page number */
001E8D AF03              MOV      R7,AR3
001E8F 123157            LCALL    ?L?COM0039
001E92         ?C0923?DRV_C2M:
001E92 D1D3              ACALL    c2m_ReadAR
001E94 EF                MOV      A,R7
001E95 20E00B            JB       ACC.0,?C0921?DRV_C2M
001E98 7829              MOV      R0,#LOW _timeout
001E9A 122FFC            LCALL    ?L?COM0005
001E9D 6004              JZ       ?C0921?DRV_C2M
001E9F 91DC              ACALL    ?L?COM0007
001EA1 80EF              SJMP     ?C0923?DRV_C2M
001EA3         ?C0921?DRV_C2M:
001EA3 12310C            LCALL    ?L?COM002A
001EA6 7028              JNZ      _exit?DRV_C2M
001EA8         ?C0925?DRV_C2M:
001EA8         ?C0918?DRV_C2M:
  560:     drv_c2m_CheckResponse(C2_TIMEOUT_VAL);
  561:     drv_c2m_WriteData(0x00);    /* initiate erase   */
001EA8 E4                CLR      A
001EA9 FF                MOV      R7,A
001EAA B1A1              ACALL    _drv_c2m_WriteData
  562:     drv_c2m_CheckResponse(C2_PAGE_ERASE_TIMEOUT_VAL);
001EAC E4                CLR      A
001EAD 752C40            MOV      _timeout+03H,#040H
001EB0 752B9C            MOV      _timeout+02H,#09CH
001EB3 F52A              MOV      _timeout+01H,A
001EB5 F529              MOV      _timeout,A
001EB7         ?C0932?DRV_C2M:
001EB7 D1D3              ACALL    c2m_ReadAR
001EB9 EF                MOV      A,R7
001EBA 20E00B            JB       ACC.0,?C0930?DRV_C2M
001EBD 7829              MOV      R0,#LOW _timeout
001EBF 122FFC            LCALL    ?L?COM0005
001EC2 6004              JZ       ?C0930?DRV_C2M
001EC4 91DC              ACALL    ?L?COM0007
001EC6 80EF              SJMP     ?C0932?DRV_C2M
001EC8         ?C0930?DRV_C2M:
001EC8 122000            LCALL    c2m_ReadDR
001ECB BF0D02            CJNE     R7,#0DH,_exit?DRV_C2M
001ECE         ?C0934?DRV_C2M:
001ECE         ?C0927?DRV_C2M:
  563:     bDone = TRUE;
001ECE D208              SETB     bDone
  564: 
  565: _exit:
001ED0         _exit:
  566:     return bDone;
001ED0 A208              MOV      C,bDone
  567: }
001ED2 22                RET      
----- FUNCTION _DRV_C2M_PageErase (END) -------


----- FUNCTION c2m_ReadAR (BEGIN) -----
 FILE: '..\drv\drv_c2m.c'
  204: static UINT8 c2m_ReadAR(void)
  205: {
  206:     BOOL    bIntState;
  207: 
  208:     c2m_SetIns(0x2);    /* instruction: read address */
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 19


001ED3 C214              CLR      bIns0
001ED5 D215              SETB     bIns1
  209: 
  210:     /* lock globally interrupt */
  211:     bIntState = DRV_INT_LockGlobalInterrupt();
001ED7 30AF05            JNB      EA,?C0190?DRV_C2M
001EDA C2AF              CLR      EA
001EDC D3                SETB     C
001EDD 8001              SJMP     ?C0191?DRV_C2M
001EDF         ?C0190?DRV_C2M:
001EDF C3                CLR      C
001EE0         ?C0191?DRV_C2M:
001EE0 12305B            LCALL    ?L?COM0014
001EE3 C297              CLR      IO_C2M_SCL
001EE5 00                NOP      
001EE6 00                NOP      
001EE7 00                NOP      
001EE8 00                NOP      
001EE9 1230A2            LCALL    ?L?COM001F
001EEC 00                NOP      
001EED 00                NOP      
001EEE 00                NOP      
001EEF 00                NOP      
001EF0 122FF1            LCALL    ?L?COM0030
001EF3 00                NOP      
001EF4 00                NOP      
001EF5 00                NOP      
001EF6 00                NOP      
001EF7 12313E            LCALL    ?L?COM0037
001EFA 00                NOP      
001EFB D297              SETB     IO_C2M_SCL
001EFD 00                NOP      
001EFE 00                NOP      
  212: 
  213:     c2m_TxStart();      /* tx frame start */
  214:     c2m_TxIns();        /* tx instruction */
  215:     c2m_TxTurnAround(); /* tx turn-around */
  216:     c2m_RxByte();       /* rx address */
001EFF 00                NOP      
001F00 00                NOP      
001F01 C297              CLR      IO_C2M_SCL
001F03 00                NOP      
001F04 00                NOP      
001F05 A2A0              MOV      C,IO_C2M_SDA
001F07 D297              SETB     IO_C2M_SCL
001F09 9200              MOV      bC2Bit0,C
001F0B 00                NOP      
001F0C 00                NOP      
001F0D C297              CLR      IO_C2M_SCL
001F0F 00                NOP      
001F10 00                NOP      
001F11 A2A0              MOV      C,IO_C2M_SDA
001F13 D297              SETB     IO_C2M_SCL
001F15 9201              MOV      bC2Bit1,C
001F17 00                NOP      
001F18 00                NOP      
001F19 C297              CLR      IO_C2M_SCL
001F1B 00                NOP      
001F1C 00                NOP      
001F1D A2A0              MOV      C,IO_C2M_SDA
001F1F D297              SETB     IO_C2M_SCL
001F21 9202              MOV      bC2Bit2,C
001F23 00                NOP      
001F24 00                NOP      
001F25 C297              CLR      IO_C2M_SCL
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 20


001F27 00                NOP      
001F28 00                NOP      
001F29 A2A0              MOV      C,IO_C2M_SDA
001F2B D297              SETB     IO_C2M_SCL
001F2D 9203              MOV      bC2Bit3,C
001F2F 00                NOP      
001F30 00                NOP      
001F31 C297              CLR      IO_C2M_SCL
001F33 00                NOP      
001F34 00                NOP      
001F35 A2A0              MOV      C,IO_C2M_SDA
001F37 D297              SETB     IO_C2M_SCL
001F39 9204              MOV      bC2Bit4,C
001F3B 00                NOP      
001F3C 00                NOP      
001F3D C297              CLR      IO_C2M_SCL
001F3F 00                NOP      
001F40 00                NOP      
001F41 A2A0              MOV      C,IO_C2M_SDA
001F43 D297              SETB     IO_C2M_SCL
001F45 9205              MOV      bC2Bit5,C
001F47 00                NOP      
001F48 00                NOP      
001F49 C297              CLR      IO_C2M_SCL
001F4B 00                NOP      
001F4C 00                NOP      
001F4D A2A0              MOV      C,IO_C2M_SDA
001F4F D297              SETB     IO_C2M_SCL
001F51 9206              MOV      bC2Bit6,C
001F53 00                NOP      
001F54 00                NOP      
001F55 C297              CLR      IO_C2M_SCL
001F57 00                NOP      
001F58 00                NOP      
001F59 123091            LCALL    ?L?COM001C
  217:     c2m_RxStop();       /* rx frame stop */
  218: 
  219:     /* unlock globally interrupt */
  220:     DRV_INT_UnlockGlobalInterrupt(bIntState);
  221: 
  222:     return c2m_GetAddr();
001F5C AF20              MOV      R7,vC2Data
  223: }
001F5E 22                RET      
----- FUNCTION c2m_ReadAR (END) -------


----- FUNCTION DRV_C2M_ChipErase (BEGIN) -----
 FILE: '..\drv\drv_c2m.c'
  507: BOOL DRV_C2M_ChipErase(void)
  508: {
  509:     BOOL    bDone = FALSE;
  510: 
001F5F C208              CLR      bDone
  511:     if (!drv_c2m_IsReady())
001F61 30975E            JNB      IO_C2M_SCL,_exit?DRV_C2M
001F64 30A05B            JNB      IO_C2M_SDA,_exit?DRV_C2M
  512:     {
  513:         /* C2 bus is not ready */
  514:         goto _exit;
  515:     }
001F67         ?C0883?DRV_C2M:
  516: 
  517:     c2m_WriteAR(vFPDAT);
001F67 AF14              MOV      R7,vFPDAT
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 21


001F69 12214E            LCALL    _c2m_WriteAR
  518:     drv_c2m_WriteData(C2_FPDAT_DEVICE_ERASE);
001F6C 7F03              MOV      R7,#03H
001F6E B1A1              ACALL    _drv_c2m_WriteData
  519:     drv_c2m_CheckResponse(C2_TIMEOUT_VAL);
001F70 E4                CLR      A
001F71 752B10            MOV      _timeout+03H,#010H
001F74 752A27            MOV      _timeout+02H,#027H
001F77 F529              MOV      _timeout+01H,A
001F79 F528              MOV      _timeout,A
001F7B         ?C0892?DRV_C2M:
001F7B D1D3              ACALL    c2m_ReadAR
001F7D EF                MOV      A,R7
001F7E 20E00B            JB       ACC.0,?C0890?DRV_C2M
001F81 7828              MOV      R0,#LOW _timeout
001F83 122FFC            LCALL    ?L?COM0005
001F86 6004              JZ       ?C0890?DRV_C2M
001F88 91DC              ACALL    ?L?COM0007
001F8A 80EF              SJMP     ?C0892?DRV_C2M
001F8C         ?C0890?DRV_C2M:
001F8C 12310C            LCALL    ?L?COM002A
001F8F 7031              JNZ      _exit?DRV_C2M
001F91         ?C0894?DRV_C2M:
001F91         ?C0887?DRV_C2M:
  520:     drv_c2m_WriteData(0xDE);     /* send sequence #1 */
001F91 7FDE              MOV      R7,#0DEH
001F93 B1A1              ACALL    _drv_c2m_WriteData
  521:     drv_c2m_WriteData(0xAD);     /* send sequence #2 */
001F95 7FAD              MOV      R7,#0ADH
001F97 B1A1              ACALL    _drv_c2m_WriteData
  522:     drv_c2m_WriteData(0xA5);     /* send sequence #3 */
001F99 7FA5              MOV      R7,#0A5H
001F9B B1A1              ACALL    _drv_c2m_WriteData
  523:     drv_c2m_CheckResponse(C2_CHIP_ERASE_TIMEOUT_VAL);
001F9D 752B00            MOV      _timeout+03H,#00H
001FA0 752A2D            MOV      _timeout+02H,#02DH
001FA3 752931            MOV      _timeout+01H,#031H
001FA6 752801            MOV      _timeout,#01H
001FA9         ?C0901?DRV_C2M:
001FA9 D1D3              ACALL    c2m_ReadAR
001FAB EF                MOV      A,R7
001FAC 20E00B            JB       ACC.0,?C0899?DRV_C2M
001FAF 7828              MOV      R0,#LOW _timeout
001FB1 122FFC            LCALL    ?L?COM0005
001FB4 6004              JZ       ?C0899?DRV_C2M
001FB6 91DC              ACALL    ?L?COM0007
001FB8 80EF              SJMP     ?C0901?DRV_C2M
001FBA         ?C0899?DRV_C2M:
001FBA 122000            LCALL    c2m_ReadDR
001FBD BF0D02            CJNE     R7,#0DH,_exit?DRV_C2M
001FC0         ?C0903?DRV_C2M:
001FC0         ?C0896?DRV_C2M:
  524:     bDone = TRUE;
001FC0 D208              SETB     bDone
  525: 
  526: _exit:
001FC2         _exit:
  527:     return bDone;
001FC2 A208              MOV      C,bDone
  528: }
001FC4 22                RET      
----- FUNCTION DRV_C2M_ChipErase (END) -------


----- FUNCTION drv_c2m_ReadData (BEGIN) -----
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 22


 FILE: '..\drv\drv_c2m.c'
  363: static UINT8 drv_c2m_ReadData(void)
  364: {
  365:     drv_c2m_PollOutBusy(C2_TIMEOUT_VAL);
  366:     return c2m_ReadDR();
001FC5 E4                CLR      A
001FC6 753910            MOV      _timeout+03H,#010H
001FC9 753827            MOV      _timeout+02H,#027H
001FCC F537              MOV      _timeout+01H,A
001FCE F536              MOV      _timeout,A
001FD0         ?C0794?DRV_C2M:
001FD0 D1D3              ACALL    c2m_ReadAR
001FD2 EF                MOV      A,R7
001FD3 20E00B            JB       ACC.0,?C0792?DRV_C2M
001FD6 7836              MOV      R0,#LOW _timeout
001FD8 122FFC            LCALL    ?L?COM0005
001FDB 6004              JZ       ?C0792?DRV_C2M
001FDD 91DC              ACALL    ?L?COM0007
001FDF 80EF              SJMP     ?C0794?DRV_C2M
001FE1         ?C0792?DRV_C2M:
  367: }
001FE1 801D              SJMP     c2m_ReadDR
----- FUNCTION drv_c2m_ReadData (END) -------


----- FUNCTION _drv_c2m_ReadSFR (BEGIN) -----
 FILE: '..\drv\drv_c2m.c'
  351: static UINT8 drv_c2m_ReadSFR(UINT8 vAddr)
  352: {
;---- Variable 'vAddr' assigned to Register 'R7' ----
  353:     c2m_WriteAR(vAddr);
  354:     return c2m_ReadDR();
001FE3 12214E            LCALL    _c2m_WriteAR
  355: }
001FE6 8018              SJMP     c2m_ReadDR
----- FUNCTION _drv_c2m_ReadSFR (END) -------


----- FUNCTION DRV_C2M_Reset (BEGIN) -----
 FILE: '..\drv\drv_c2m.c'
  416: BOOL DRV_C2M_Reset(void)
  417: {
  418:     if (!drv_c2m_IsReady())
  419:     {
001FE8 309703            JNB      IO_C2M_SCL,?C0824?DRV_C2M
001FEB 20A002            JB       IO_C2M_SDA,?C0831?DRV_C2M
001FEE         ?C0824?DRV_C2M:
  420:         /* C2 bus is not ready */
  421:         return FALSE;
001FEE C3                CLR      C
001FEF 22                RET      
  422:     }
  423: 
  424:     c2m_Reset();
001FF0         ?C0831?DRV_C2M:
001FF0 1230BF            LCALL    ?L?COM0022
  425:     return TRUE;
001FF3 D3                SETB     C
  426: }
001FF4 22                RET      
----- FUNCTION DRV_C2M_Reset (END) -------


----- FUNCTION CMD_System_Clear (BEGIN) -----
 FILE: '..\cli\cmd\cmd_system.c'
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 23


   40: void CMD_System_Clear(void)
   41: {
   42:     VT_ClearScreen(0);
   43: }
001FF5 E4                CLR      A
001FF6 FF                MOV      R7,A
001FF7 0225AB            LJMP     _VT_ClearScreen
----- FUNCTION CMD_System_Clear (END) -------


----- FUNCTION c2m_ReadDR (BEGIN) -----
 FILE: '..\drv\drv_c2m.c'
  250: static UINT8 c2m_ReadDR(void)
  251: {
  252:     BOOL    bIntState;
  253: 
  254:     c2m_SetIns(0x0);    /* instruction: read data */
002000 C214              CLR      bIns0
002002 C215              CLR      bIns1
  255:     c2m_SetLength(0x1); /* length: 1 byte */
002004 C216              CLR      bLength0
002006 C217              CLR      bLength1
  256: 
  257:     /* lock globally interrupt */
  258:     bIntState = DRV_INT_LockGlobalInterrupt();
002008 30AF05            JNB      EA,?C0584?DRV_C2M
00200B C2AF              CLR      EA
00200D D3                SETB     C
00200E 8001              SJMP     ?C0585?DRV_C2M
002010         ?C0584?DRV_C2M:
002010 C3                CLR      C
002011         ?C0585?DRV_C2M:
002011 12305B            LCALL    ?L?COM0014
002014 C297              CLR      IO_C2M_SCL
002016 00                NOP      
002017 00                NOP      
002018 00                NOP      
002019 00                NOP      
00201A 1230A2            LCALL    ?L?COM001F
00201D 00                NOP      
00201E 00                NOP      
00201F 00                NOP      
002020 00                NOP      
002021 122FF1            LCALL    ?L?COM0030
002024 00                NOP      
002025 00                NOP      
002026 00                NOP      
002027 00                NOP      
002028 1231CC            LCALL    ?L?COM0048
00202B 00                NOP      
00202C 00                NOP      
00202D 00                NOP      
00202E 00                NOP      
00202F 1231C3            LCALL    ?L?COM0047
002032 00                NOP      
002033 00                NOP      
002034 00                NOP      
002035 00                NOP      
002036 12313E            LCALL    ?L?COM0037
002039 00                NOP      
00203A D297              SETB     IO_C2M_SCL
00203C 00                NOP      
00203D 00                NOP      
  259: 
  260:     c2m_TxStart();      /* tx frame start */
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 24


  261:     c2m_TxIns();        /* tx instruction */
  262:     c2m_TxLength();     /* tx length */
  263:     c2m_TxTurnAround(); /* tx turn-around */
  264:     c2m_Wait();         /* wait for target device ready */
00203E 753A27            MOV      _timeout,#027H
002041 753B10            MOV      _timeout+01H,#010H
002044         ?C0687?DRV_C2M:
002044 00                NOP      
002045 00                NOP      
002046 C297              CLR      IO_C2M_SCL
002048 00                NOP      
002049 00                NOP      
00204A 121CD6            LCALL    ?L?COM0006
00204D 20000D            JB       bC2Bit0,?C0700?DRV_C2M
002050 E53B              MOV      A,_timeout+01H
002052 153B              DEC      _timeout+01H
002054 AE3A              MOV      R6,_timeout
002056 7002              JNZ      ?C1014?DRV_C2M
002058 153A              DEC      _timeout
00205A         ?C1014?DRV_C2M:
00205A 4E                ORL      A,R6
00205B 70E7              JNZ      ?C0687?DRV_C2M
  265:     c2m_RxByte();       /* rx data */
00205D         ?C0700?DRV_C2M:
00205D 00                NOP      
00205E 00                NOP      
00205F C297              CLR      IO_C2M_SCL
002061 00                NOP      
002062 00                NOP      
002063 A2A0              MOV      C,IO_C2M_SDA
002065 D297              SETB     IO_C2M_SCL
002067 9200              MOV      bC2Bit0,C
002069 00                NOP      
00206A 00                NOP      
00206B C297              CLR      IO_C2M_SCL
00206D 00                NOP      
00206E 00                NOP      
00206F A2A0              MOV      C,IO_C2M_SDA
002071 D297              SETB     IO_C2M_SCL
002073 9201              MOV      bC2Bit1,C
002075 00                NOP      
002076 00                NOP      
002077 C297              CLR      IO_C2M_SCL
002079 00                NOP      
00207A 00                NOP      
00207B A2A0              MOV      C,IO_C2M_SDA
00207D D297              SETB     IO_C2M_SCL
00207F 9202              MOV      bC2Bit2,C
002081 00                NOP      
002082 00                NOP      
002083 C297              CLR      IO_C2M_SCL
002085 00                NOP      
002086 00                NOP      
002087 A2A0              MOV      C,IO_C2M_SDA
002089 D297              SETB     IO_C2M_SCL
00208B 9203              MOV      bC2Bit3,C
00208D 00                NOP      
00208E 00                NOP      
00208F C297              CLR      IO_C2M_SCL
002091 00                NOP      
002092 00                NOP      
002093 A2A0              MOV      C,IO_C2M_SDA
002095 D297              SETB     IO_C2M_SCL
002097 9204              MOV      bC2Bit4,C
002099 00                NOP      
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 25


00209A 00                NOP      
00209B C297              CLR      IO_C2M_SCL
00209D 00                NOP      
00209E 00                NOP      
00209F A2A0              MOV      C,IO_C2M_SDA
0020A1 D297              SETB     IO_C2M_SCL
0020A3 9205              MOV      bC2Bit5,C
0020A5 00                NOP      
0020A6 00                NOP      
0020A7 C297              CLR      IO_C2M_SCL
0020A9 00                NOP      
0020AA 00                NOP      
0020AB A2A0              MOV      C,IO_C2M_SDA
0020AD D297              SETB     IO_C2M_SCL
0020AF 9206              MOV      bC2Bit6,C
0020B1 00                NOP      
0020B2 00                NOP      
0020B3 C297              CLR      IO_C2M_SCL
0020B5 00                NOP      
0020B6 00                NOP      
0020B7 123091            LCALL    ?L?COM001C
  266:     c2m_RxStop();       /* rx frame stop */
  267: 
  268:     /* unlock globally interrupt */
  269:     DRV_INT_UnlockGlobalInterrupt(bIntState);
  270: 
  271:     return c2m_GetData();
0020BA AF20              MOV      R7,vC2Data
  272: }
0020BC 22                RET      
----- FUNCTION c2m_ReadDR (END) -------


----- FUNCTION _DRV_C2M_FlashRead (BEGIN) -----
 FILE: '..\drv\drv_c2m.c'
  587: BOOL DRV_C2M_FlashRead
  588: (
0020BD 8E2C              MOV      pBuf,R6
0020BF 8F2D              MOV      pBuf+01H,R7
0020C1 8C2E              MOV      vAddr,R4
0020C3 8D2F              MOV      vAddr+01H,R5
;---- Variable 'vCount' assigned to Register 'R3' ----
  589:     OUT UINT8 SEG_XDATA *pBuf,
  590:     IN  UINT16           vAddr,
  591:     IN  UINT8            vCount
  592: )
  593: {
  594:     UINT16  vLen = ((vCount==0)?256:vCount);
0020C5 EB                MOV      A,R3
0020C6 7005              JNZ      ?C0936?DRV_C2M
0020C8 7E01              MOV      R6,#01H
0020CA FF                MOV      R7,A
0020CB 8004              SJMP     ?C0937?DRV_C2M
0020CD         ?C0936?DRV_C2M:
0020CD EB                MOV      A,R3
0020CE FF                MOV      R7,A
0020CF 7E00              MOV      R6,#00H
0020D1         ?C0937?DRV_C2M:
0020D1 8E30              MOV      vLen,R6
0020D3 8F31              MOV      vLen+01H,R7
  595:     BOOL    bDone = FALSE;
0020D5 C208              CLR      bDone
  596: 
  597:     if (!drv_c2m_IsReady())
0020D7 309771            JNB      IO_C2M_SCL,_exit?DRV_C2M
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 26


0020DA 30A06E            JNB      IO_C2M_SDA,_exit?DRV_C2M
  598:     {
  599:         /* C2 bus is not ready */
  600:         goto _exit;
  601:     }
0020DD         ?C0938?DRV_C2M:
  602: 
  603:     c2m_WriteAR(vFPDAT);
0020DD AF14              MOV      R7,vFPDAT
0020DF 314E              ACALL    _c2m_WriteAR
  604:     drv_c2m_WriteData(C2_FPDAT_BLOCK_READ);
0020E1 7F06              MOV      R7,#06H
0020E3 123148            LCALL    ?L?COM0038
0020E6         ?C0947?DRV_C2M:
0020E6 121ED3            LCALL    c2m_ReadAR
0020E9 EF                MOV      A,R7
0020EA 20E00C            JB       ACC.0,?C0945?DRV_C2M
0020ED 7832              MOV      R0,#LOW _timeout
0020EF 122FFC            LCALL    ?L?COM0005
0020F2 6005              JZ       ?C0945?DRV_C2M
0020F4 121CDC            LCALL    ?L?COM0007
0020F7 80ED              SJMP     ?C0947?DRV_C2M
0020F9         ?C0945?DRV_C2M:
0020F9 12310C            LCALL    ?L?COM002A
0020FC 704D              JNZ      _exit?DRV_C2M
0020FE         ?C0949?DRV_C2M:
0020FE         ?C0942?DRV_C2M:
  605:     drv_c2m_CheckResponse(C2_TIMEOUT_VAL);
  606:     drv_c2m_WriteData(vAddr>>8);    /* MSB of address */
0020FE E52E              MOV      A,vAddr
002100 FF                MOV      R7,A
002101 121DA1            LCALL    _drv_c2m_WriteData
  607:     drv_c2m_WriteData(vAddr&0xFF);  /* LSB of address */
002104 AF2F              MOV      R7,vAddr+01H
002106 121DA1            LCALL    _drv_c2m_WriteData
  608:     drv_c2m_WriteData(vCount);      /* read length    */
002109 AF03              MOV      R7,AR3
00210B 123148            LCALL    ?L?COM0038
00210E         ?C0956?DRV_C2M:
00210E 121ED3            LCALL    c2m_ReadAR
002111 EF                MOV      A,R7
002112 20E00C            JB       ACC.0,?C0954?DRV_C2M
002115 7832              MOV      R0,#LOW _timeout
002117 122FFC            LCALL    ?L?COM0005
00211A 6005              JZ       ?C0954?DRV_C2M
00211C 121CDC            LCALL    ?L?COM0007
00211F 80ED              SJMP     ?C0956?DRV_C2M
002121         ?C0954?DRV_C2M:
002121 1100              ACALL    c2m_ReadDR
002123 BF0D25            CJNE     R7,#0DH,_exit?DRV_C2M
002126         ?C0958?DRV_C2M:
002126         ?C0959?DRV_C2M:
  609:     drv_c2m_CheckResponse(C2_TIMEOUT_VAL);
  610:     while (vLen--)
002126 E531              MOV      A,vLen+01H
002128 1531              DEC      vLen+01H
00212A AE30              MOV      R6,vLen
00212C 7002              JNZ      ?C1016?DRV_C2M
00212E 1530              DEC      vLen
002130         ?C1016?DRV_C2M:
002130 4E                ORL      A,R6
002131 6016              JZ       ?C0960?DRV_C2M
  611:     {
  612:         /* read flash data into buffer */
  613:         *pBuf++ = drv_c2m_ReadData();
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 27


002133 121FC5            LCALL    drv_c2m_ReadData
002136 052D              INC      pBuf+01H
002138 E52D              MOV      A,pBuf+01H
00213A AC2C              MOV      R4,pBuf
00213C 7002              JNZ      ?C1017?DRV_C2M
00213E 052C              INC      pBuf
002140         ?C1017?DRV_C2M:
002140 14                DEC      A
002141 F582              MOV      DPL,A
002143 8C83              MOV      DPH,R4
002145 EF                MOV      A,R7
002146 F0                MOVX     @DPTR,A
  614:     }
002147 80DD              SJMP     ?C0959?DRV_C2M
002149         ?C0960?DRV_C2M:
  615:     bDone = TRUE;
002149 D208              SETB     bDone
  616: 
  617: _exit:
00214B         _exit:
  618:     return bDone;
00214B A208              MOV      C,bDone
  619: }
00214D 22                RET      
----- FUNCTION _DRV_C2M_FlashRead (END) -------


----- FUNCTION _c2m_WriteAR (BEGIN) -----
 FILE: '..\drv\drv_c2m.c'
  184: static void c2m_WriteAR(UINT8 vAddr)
  185: {
;---- Variable 'vAddr' assigned to Register 'R7' ----
  186:     BOOL    bIntState;
  187: 
  188:     c2m_SetIns(0x3);    /* instruction: write address */
00214E D214              SETB     bIns0
002150 D215              SETB     bIns1
  189:     c2m_SetAddr(vAddr);
002152 8F20              MOV      vC2Data,R7
  190: 
  191:     /* lock globally interrupt */
  192:     bIntState = DRV_INT_LockGlobalInterrupt();
002154 30AF05            JNB      EA,?C0007?DRV_C2M
002157 C2AF              CLR      EA
002159 D3                SETB     C
00215A 8001              SJMP     ?C0008?DRV_C2M
00215C         ?C0007?DRV_C2M:
00215C C3                CLR      C
00215D         ?C0008?DRV_C2M:
00215D 12305B            LCALL    ?L?COM0014
002160 C297              CLR      IO_C2M_SCL
002162 00                NOP      
002163 00                NOP      
002164 00                NOP      
002165 00                NOP      
002166 1230A2            LCALL    ?L?COM001F
002169 00                NOP      
00216A 00                NOP      
00216B 00                NOP      
00216C 00                NOP      
00216D 122FF1            LCALL    ?L?COM0030
002170 00                NOP      
002171 00                NOP      
002172 00                NOP      
002173 00                NOP      
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 28


002174 123214            LCALL    ?L?COM0050
002177 00                NOP      
002178 00                NOP      
002179 00                NOP      
00217A 00                NOP      
00217B 12320B            LCALL    ?L?COM004F
00217E 00                NOP      
00217F 00                NOP      
002180 00                NOP      
002181 00                NOP      
002182 123202            LCALL    ?L?COM004E
002185 00                NOP      
002186 00                NOP      
002187 00                NOP      
002188 00                NOP      
002189 1231F9            LCALL    ?L?COM004D
00218C 00                NOP      
00218D 00                NOP      
00218E 00                NOP      
00218F 00                NOP      
002190 1231F0            LCALL    ?L?COM004C
002193 00                NOP      
002194 00                NOP      
002195 00                NOP      
002196 00                NOP      
002197 1231E7            LCALL    ?L?COM004B
00219A 00                NOP      
00219B 00                NOP      
00219C 00                NOP      
00219D 00                NOP      
00219E 1231DE            LCALL    ?L?COM004A
0021A1 00                NOP      
0021A2 00                NOP      
0021A3 00                NOP      
0021A4 00                NOP      
0021A5 1231D5            LCALL    ?L?COM0049
0021A8 00                NOP      
0021A9 00                NOP      
0021AA 00                NOP      
0021AB 00                NOP      
0021AC D297              SETB     IO_C2M_SCL
  193: 
  194:     c2m_TxStart();      /* tx frame start */
  195:     c2m_TxIns();        /* tx instruction */
  196:     c2m_TxByte();       /* tx address */
  197:     c2m_TxStop();       /* tx frame stop */
0021AE D2A0              SETB     IO_C2M_SDA
0021B0 53A6FE            ANL      P2MDOUT,#0FEH
0021B3 A212              MOV      C,bHigh
0021B5 92A0              MOV      IO_C2M_SDA,C
0021B7 C297              CLR      IO_C2M_SCL
0021B9 00                NOP      
0021BA 00                NOP      
0021BB 00                NOP      
0021BC 00                NOP      
0021BD D297              SETB     IO_C2M_SCL
0021BF 02309A            LJMP     ?L?COM001E
  198: 
  199:     /* unlock globally interrupt */
  200:     DRV_INT_UnlockGlobalInterrupt(bIntState);
----- FUNCTION _c2m_WriteAR (END) -------


----- FUNCTION _DRV_CPU_DelayMs (BEGIN) -----
 FILE: '..\drv\drv_cpu.c'
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 29


   67: void DRV_CPU_DelayMs(UINT16 vMsec)
   68: {
;---- Variable 'vMsec' assigned to Register 'DPTR' ----
0021C2 8F82              MOV      DPL,R7
0021C4 8E83              MOV      DPH,R6
   69:   #if DRV_TIMER_SUPPORT
   70:     if (DRV_INT_IsGlobalInterruptEnable())
0021C6 30AF26            JNB      EA,?C0008?DRV_CPU
   71:     {
   72:         UINT64  vStopTick = DRV_TIMER_GetTick() + vMsec/DRV_TIMER_INTERVAL;
0021C9 EF                MOV      A,R7
0021CA 250B              ADD      A,vTickCount+03H
0021CC F533              MOV      vStopTick+03H,A
0021CE EE                MOV      A,R6
0021CF 350A              ADDC     A,vTickCount+02H
0021D1 F532              MOV      vStopTick+02H,A
0021D3 E4                CLR      A
0021D4 3509              ADDC     A,vTickCount+01H
0021D6 F531              MOV      vStopTick+01H,A
0021D8 E4                CLR      A
0021D9 3508              ADDC     A,vTickCount
0021DB F530              MOV      vStopTick,A
0021DD         ?C0005?DRV_CPU:
   73: 
   74:         while (DRV_TIMER_GetTick() < vStopTick)
0021DD AF33              MOV      R7,vStopTick+03H
0021DF AE32              MOV      R6,vStopTick+02H
0021E1 AD31              MOV      R5,vStopTick+01H
0021E3 AC30              MOV      R4,vStopTick
0021E5 12301E            LCALL    ?L?COM000A
0021E8 501E              JNC      ?C0010?DRV_CPU
   75:         {
   76:           #if DRV_WATCHDOG_SUPPORT
   77:             DRV_WATCHDOG_Kick();
0021EA E4                CLR      A
0021EB F5FE              MOV      PCA0CPH4,A
   78:           #endif
   79:         }
0021ED 80EE              SJMP     ?C0005?DRV_CPU
   80:     }
   81:     else
   82:   #endif
   83:     {
0021EF         ?C0008?DRV_CPU:
   84:     	while (vMsec--)
0021EF E582              MOV      A,DPL
0021F1 1582              DEC      DPL
0021F3 AE83              MOV      R6,DPH
0021F5 7002              JNZ      ?C0012?DRV_CPU
0021F7 1583              DEC      DPH
0021F9         ?C0012?DRV_CPU:
0021F9 4E                ORL      A,R6
0021FA 600C              JZ       ?C0010?DRV_CPU
   85:     	{
   86:           #if DRV_WATCHDOG_SUPPORT
   87:     		DRV_WATCHDOG_Kick();
0021FC E4                CLR      A
0021FD F5FE              MOV      PCA0CPH4,A
   88:           #endif
   89: 
   90:     		DRV_CPU_DelayUs(1000);
0021FF 7FE8              MOV      R7,#0E8H
002201 7E03              MOV      R6,#03H
002203 121CE0            LCALL    _DRV_CPU_DelayUs
   91:     	}
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 30


002206 80E7              SJMP     ?C0008?DRV_CPU
   92:     }
   93: }
002208         ?C0010?DRV_CPU:
002208 22                RET      
----- FUNCTION _DRV_CPU_DelayMs (END) -------


----- FUNCTION ?L?COM0023 (BEGIN) -----
002209 74FF              MOV      A,#0FFH
00220B FF                MOV      R7,A
00220C FE                MOV      R6,A
----- FUNCTION __getchar (BEGIN) -----
 FILE: '..\lib\_stdio.c'
   37: int _getchar(int timeout)
   38: {
00220D 8E2A              MOV      timeout,R6
00220F 8F2B              MOV      timeout+01H,R7
   39:     if (timeout != NO_PENDING)
   40:     {
002211 E52B              MOV      A,timeout+01H
002213 452A              ORL      A,timeout
002215 6021              JZ       ?C0001?_STDIO
   41:         while (__is_rx_empty())
002217         ?C0002?_STDIO:
   42:         {
002217 20981E            JB       RI0,?C0001?_STDIO
   43:             if ((timeout >= 0) && (timeout-- == 0))
   44:             {
00221A C3                CLR      C
00221B E52A              MOV      A,timeout
00221D 6480              XRL      A,#080H
00221F 9480              SUBB     A,#080H
002221 400D              JC       ?C0004?_STDIO
002223 E52B              MOV      A,timeout+01H
002225 152B              DEC      timeout+01H
002227 AE2A              MOV      R6,timeout
002229 7002              JNZ      ?C0008?_STDIO
00222B 152A              DEC      timeout
00222D         ?C0008?_STDIO:
00222D 4E                ORL      A,R6
00222E 6008              JZ       ?C0001?_STDIO
   45:                 break;
   46:             }
   47: 
002230         ?C0004?_STDIO:
   48:             __delayms(1);
002230 7F01              MOV      R7,#01H
002232 7E00              MOV      R6,#00H
002234 31C2              ACALL    _DRV_CPU_DelayMs
   49:         }
002236 80DF              SJMP     ?C0002?_STDIO
   50:     }
002238         ?C0001?_STDIO:
   51: 
   52:     return (__is_rx_empty()? -1 : __getchar());
002238 209806            JB       RI0,?C0005?_STDIO
00223B 7EFF              MOV      R6,#0FFH
00223D 7FFF              MOV      R7,#0FFH
00223F 8006              SJMP     ?C0006?_STDIO
002241         ?C0005?_STDIO:
002241 C298              CLR      RI0
002243 AF99              MOV      R7,SBUF0
002245 7E00              MOV      R6,#00H
002247         ?C0006?_STDIO:
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 31


   53: }
002247 22                RET      
----- FUNCTION __getchar (END) -------


----- FUNCTION cli_ReadCmd (BEGIN) -----
 FILE: '..\cli\thread_cli.c'
   86: static BOOL cli_ReadCmd(void)
   87: {
   88:   #define CLEAR_CMD_ON_SCREEN()                                     \
002248         ?C0005?THREAD_CLI:
   89:         do {                                                        \
   90:             /* move cursor to the end of this command */            \
   91:             while (vCmdBufCount < strlen(aCmdBuf))                  \
   92:             {                                                       \
   93:                 VT_MoveRight(1);                                    \
   94:                 vCmdBufCount++;                                     \
   95:             }                                                       \
   96:                                                                     \
   97:             /* clear command on screen */                           \
   98:             while (vCmdBufCount > 0)                                \
   99:             {                                                       \
  100:                 VT_Printf("\b \b");                                 \
  101:                 vCmdBufCount--;                                     \
  102:             }                                                       \
  103:         } while (0)
  104: 
  105:     int vKey;
  106: 
  107:     while ((vKey = VT_ReadKey(NO_PENDING)) != -1)
002248 E4                CLR      A
002249 FF                MOV      R7,A
00224A FE                MOV      R6,A
00224B 510D              ACALL    __getchar
00224D 8E25              MOV      vKey,R6
00224F 8F26              MOV      vKey+01H,R7
002251 EF                MOV      A,R7
002252 F4                CPL      A
002253 7002              JNZ      ?C0115?THREAD_CLI
002255 EE                MOV      A,R6
002256 F4                CPL      A
002257         ?C0115?THREAD_CLI:
002257 7002              JNZ      $ + 4H
002259 815A              AJMP     ?C0006?THREAD_CLI
  108:     {
  109:         switch (vKey)
00225B E525              MOV      A,vKey
00225D 6002              JZ       $ + 4H
00225F 61D9              AJMP     ?C0051?THREAD_CLI
002261 E526              MOV      A,vKey+01H
002263 1202BE            LCALL    ?C?CCASE
002266 23B5              DW       ?C0049?THREAD_CLI
002268 08                DB       08H
002269 228B              DW       ?C0009?THREAD_CLI
00226B 0A                DB       0AH
00226C 228B              DW       ?C0009?THREAD_CLI
00226E 0D                DB       0DH
00226F 2340              DW       ?C0037?THREAD_CLI
002271 1A                DB       01AH
002272 239A              DW       ?C0047?THREAD_CLI
002274 7F                DB       07FH
002275 237A              DW       ?C0045?THREAD_CLI
002277 81                DB       081H
002278 2388              DW       ?C0046?THREAD_CLI
00227A 82                DB       082H
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 32


00227B 22D9              DW       ?C0021?THREAD_CLI
00227D 85                DB       085H
00227E 22F9              DW       ?C0029?THREAD_CLI
002280 86                DB       086H
002281 2359              DW       ?C0041?THREAD_CLI
002283 87                DB       087H
002284 2369              DW       ?C0043?THREAD_CLI
002286 88                DB       088H
002287 0000              DW       00H
002289 23D9              DW       ?C0051?THREAD_CLI
  110:         {
  111:             case VT_KEY_CR:     /* command received */
  112:             case VT_KEY_LF:
00228B         ?C0009?THREAD_CLI:
  113:                 _trimAll(aCmdBuf);
00228B 7E01              MOV      R6,#HIGH aCmdBuf
00228D 7F5B              MOV      R7,#LOW aCmdBuf
00228F D16F              ACALL    __trimAll
  114:           #if CLI_CMD_HISTORY_SUPPORT
  115:                 cli_HistoryAppend(aCmdBuf);
002291 7B01              MOV      R3,#01H
002293 7A01              MOV      R2,#HIGH aCmdBuf
002295 795B              MOV      R1,#LOW aCmdBuf
002297 12308A            LCALL    ?L?COM001B
00229A 7001              JNZ      ?C0014?THREAD_CLI
00229C D3                SETB     C
00229D         ?C0014?THREAD_CLI:
00229D         ?C0015?THREAD_CLI:
00229D 402D              JC       ?C0013?THREAD_CLI
00229F 900015            MOV      DPTR,#vHistoryLatest
0022A2 E0                MOVX     A,@DPTR
0022A3 FF                MOV      R7,A
0022A4 04                INC      A
0022A5 F0                MOVX     @DPTR,A
0022A6 EF                MOV      A,R7
0022A7 1230B3            LCALL    ?L?COM0021
0022AA A801              MOV      R0,AR1
0022AC FC                MOV      R4,A
0022AD 7D01              MOV      R5,#01H
0022AF 7B01              MOV      R3,#01H
0022B1 7A01              MOV      R2,#HIGH aCmdBuf
0022B3 795B              MOV      R1,#LOW aCmdBuf
0022B5 12057E            LCALL    ?C?STRCPY
0022B8 900015            MOV      DPTR,#vHistoryLatest
0022BB 1230AE            LCALL    ?L?COM0020
0022BE A801              MOV      R0,AR1
0022C0 FC                MOV      R4,A
0022C1 7D01              MOV      R5,#01H
0022C3 7BFF              MOV      R3,#0FFH
0022C5 7A0B              MOV      R2,#HIGH 01000B3DH
0022C7 793D              MOV      R1,#LOW 01000B3DH
0022C9 12057E            LCALL    ?C?STRCPY
0022CC         ?C0013?THREAD_CLI:
0022CC 900015            MOV      DPTR,#vHistoryLatest
0022CF E0                MOVX     A,@DPTR
0022D0 A3                INC      DPTR
0022D1 F0                MOVX     @DPTR,A
  116:           #endif
  117:                 vCmdBufCount = 0;
0022D2 E4                CLR      A
0022D3 9001AC            MOV      DPTR,#vCmdBufCount
0022D6 F0                MOVX     @DPTR,A
  118:                 return TRUE;
0022D7 D3                SETB     C
0022D8 22                RET      
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 33


  119: 
  120:           #if CLI_CMD_HISTORY_SUPPORT
  121:             case VT_KEY_UP:
  122:                 CLEAR_CMD_ON_SCREEN();
0022D9         ?C0021?THREAD_CLI:
0022D9 123006            LCALL    ?L?COM0008
0022DC E0                MOVX     A,@DPTR
0022DD C3                CLR      C
0022DE 9F                SUBB     A,R7
0022DF E4                CLR      A
0022E0 9E                SUBB     A,R6
0022E1 5005              JNC      ?C0023?THREAD_CLI
0022E3 12303F            LCALL    ?L?COM0010
0022E6 80F1              SJMP     ?C0021?THREAD_CLI
0022E8         ?C0023?THREAD_CLI:
0022E8 123113            LCALL    ?L?COM002D
0022EB 4005              JC       ?C0019?THREAD_CLI
0022ED 12304B            LCALL    ?L?COM0012
0022F0 80F6              SJMP     ?C0023?THREAD_CLI
0022F2         ?C0019?THREAD_CLI:
  123: 
  124:                 /* load from history */
  125:                 strcpy(aCmdBuf, cli_HistoryGetPrev());
0022F2 900016            MOV      DPTR,#vHistoryCurrent
0022F5 E0                MOVX     A,@DPTR
0022F6 14                DEC      A
  126:                 vCmdBufCount = strlen(aCmdBuf);
  127: 
  128:                 /* display new command */
  129:                 VT_Printf("%s", aCmdBuf);
  130:                 break;
0022F7 801E              SJMP     ?C0120?THREAD_CLI
  131: 
  132:             case VT_KEY_DOWN:
  133:                 CLEAR_CMD_ON_SCREEN();
0022F9         ?C0029?THREAD_CLI:
0022F9 123006            LCALL    ?L?COM0008
0022FC E0                MOVX     A,@DPTR
0022FD C3                CLR      C
0022FE 9F                SUBB     A,R7
0022FF E4                CLR      A
002300 9E                SUBB     A,R6
002301 5005              JNC      ?C0031?THREAD_CLI
002303 12303F            LCALL    ?L?COM0010
002306 80F1              SJMP     ?C0029?THREAD_CLI
002308         ?C0031?THREAD_CLI:
002308 123113            LCALL    ?L?COM002D
00230B 4005              JC       ?C0027?THREAD_CLI
00230D 12304B            LCALL    ?L?COM0012
002310 80F6              SJMP     ?C0031?THREAD_CLI
002312         ?C0027?THREAD_CLI:
  134: 
  135:                 /* load from history */
  136:                 strcpy(aCmdBuf, cli_HistoryGetNext());
002312 900016            MOV      DPTR,#vHistoryCurrent
002315 E0                MOVX     A,@DPTR
002316 04                INC      A
002317         
002317 F0                MOVX     @DPTR,A
002318 1230AE            LCALL    ?L?COM0020
00231B FA                MOV      R2,A
00231C 7B01              MOV      R3,#01H
00231E 785B              MOV      R0,#LOW aCmdBuf
002320 7C01              MOV      R4,#HIGH aCmdBuf
002322 7D01              MOV      R5,#01H
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 34


002324 12057E            LCALL    ?C?STRCPY
  137:                 vCmdBufCount = strlen(aCmdBuf);
002327 123006            LCALL    ?L?COM0008
00232A EF                MOV      A,R7
00232B F0                MOVX     @DPTR,A
  138: 
  139:                 /* display new command */
  140:                 VT_Printf("%s", aCmdBuf);
00232C 753301            MOV      ?_printf?BYTE+03H,#01H
00232F 753401            MOV      ?_printf?BYTE+04H,#HIGH aCmdBuf
002332 75355B            MOV      ?_printf?BYTE+05H,#LOW aCmdBuf
002335 7BFF              MOV      R3,#0FFH
002337 7A0B              MOV      R2,#HIGH 01000B42H
002339 7942              MOV      R1,#LOW 01000B42H
00233B 120700            LCALL    _printf
  141:                 break;
00233E 4148              AJMP     ?C0005?THREAD_CLI
  142:           #endif
  143: 
  144:           #if CLI_CMD_EDIT_SUPPORT
  145:     		case VT_KEY_CTRL_Z:  /* clear current command */
  146:                 CLEAR_CMD_ON_SCREEN();
002340         ?C0037?THREAD_CLI:
002340 123006            LCALL    ?L?COM0008
002343 E0                MOVX     A,@DPTR
002344 C3                CLR      C
002345 9F                SUBB     A,R7
002346 E4                CLR      A
002347 9E                SUBB     A,R6
002348 5005              JNC      ?C0039?THREAD_CLI
00234A 12303F            LCALL    ?L?COM0010
00234D 80F1              SJMP     ?C0037?THREAD_CLI
00234F         ?C0039?THREAD_CLI:
00234F 123113            LCALL    ?L?COM002D
002352 402D              JC       ?C0121?THREAD_CLI
002354 12304B            LCALL    ?L?COM0012
002357 80F6              SJMP     ?C0039?THREAD_CLI
  147:                 vCmdBufCount = 0;
  148:                 break;
  149: 
  150:     		case VT_KEY_LEFT:
002359         ?C0041?THREAD_CLI:
  151:     			if (vCmdBufCount > 0)
002359 123113            LCALL    ?L?COM002D
00235C 5002              JNC      $ + 4H
00235E 4148              AJMP     ?C0005?THREAD_CLI
  152:     			{
  153:     				VT_MoveLeft(1);
002360 7F01              MOV      R7,#01H
002362 916E              ACALL    _VT_MoveLeft
  154:                     vCmdBufCount--;
002364 123054            LCALL    ?L?COM0013
  155:     			}
  156:     			break;
002367 4148              AJMP     ?C0005?THREAD_CLI
  157: 
  158:     		case VT_KEY_RIGHT:
002369         ?C0043?THREAD_CLI:
  159:     			if (vCmdBufCount < strlen(aCmdBuf))
002369 123006            LCALL    ?L?COM0008
00236C E0                MOVX     A,@DPTR
00236D C3                CLR      C
00236E 9F                SUBB     A,R7
00236F E4                CLR      A
002370 9E                SUBB     A,R6
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 35


002371 4002              JC       $ + 4H
002373 4148              AJMP     ?C0005?THREAD_CLI
  160:     			{
  161:     				VT_MoveRight(1);
002375 12303F            LCALL    ?L?COM0010
  162:                     vCmdBufCount++;
  163:     			}
  164:     			break;
002378 4148              AJMP     ?C0005?THREAD_CLI
  165: 
  166:     		case VT_KEY_HOME:
00237A         ?C0045?THREAD_CLI:
  167:                 VT_MoveLeft(vCmdBufCount);
00237A 9001AC            MOV      DPTR,#vCmdBufCount
00237D E0                MOVX     A,@DPTR
00237E FF                MOV      R7,A
00237F 916E              ACALL    _VT_MoveLeft
  168:                 vCmdBufCount = 0;
002381         
002381 E4                CLR      A
002382 9001AC            MOV      DPTR,#vCmdBufCount
002385 F0                MOVX     @DPTR,A
  169:                 break;
002386 4148              AJMP     ?C0005?THREAD_CLI
  170: 
  171:     		case VT_KEY_END:
002388         ?C0046?THREAD_CLI:
  172:                 VT_MoveRight(strlen(aCmdBuf) - vCmdBufCount);
002388 123006            LCALL    ?L?COM0008
00238B E0                MOVX     A,@DPTR
00238C FE                MOV      R6,A
00238D C3                CLR      C
00238E EF                MOV      A,R7
00238F 9E                SUBB     A,R6
002390 FF                MOV      R7,A
002391 915C              ACALL    _VT_MoveRight
  173:                 vCmdBufCount = strlen(aCmdBuf);
002393 123006            LCALL    ?L?COM0008
002396 EF                MOV      A,R7
002397 F0                MOVX     @DPTR,A
  174:                 break;
002398 4148              AJMP     ?C0005?THREAD_CLI
  175: 
  176:             case VT_KEY_DEL:
00239A         ?C0047?THREAD_CLI:
  177:                 if (vCmdBufCount < strlen(aCmdBuf))
00239A 123006            LCALL    ?L?COM0008
00239D E0                MOVX     A,@DPTR
00239E C3                CLR      C
00239F 9F                SUBB     A,R7
0023A0 E4                CLR      A
0023A1 9E                SUBB     A,R6
0023A2 4002              JC       $ + 4H
0023A4 4148              AJMP     ?C0005?THREAD_CLI
  178:                 {
  179:                     strcpy(aCmdBuf+vCmdBufCount, aCmdBuf+vCmdBufCount+1);
0023A6 1231A9            LCALL    ?L?COM0042
0023A9 C001              PUSH     AR1
0023AB 123190            LCALL    ?L?COM003E
0023AE D001              POP      AR1
0023B0 12057E            LCALL    ?C?STRCPY
  180:                     VT_SaveCursorPosition();
  181:                     VT_Printf("%s ", aCmdBuf+vCmdBufCount);
  182:                     VT_RestoreCursorPosition();
  183:                 }
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 36


  184:                 break;
0023B3 801B              SJMP     ?C0122?THREAD_CLI
  185:           #endif
  186: 
  187:             case VT_KEY_BS:
0023B5         ?C0049?THREAD_CLI:
  188:                 if (vCmdBufCount > 0)
0023B5 123113            LCALL    ?L?COM002D
0023B8 5002              JNC      $ + 4H
0023BA 4148              AJMP     ?C0005?THREAD_CLI
  189:                 {
  190:                     vCmdBufCount--;
0023BC E0                MOVX     A,@DPTR
0023BD 14                DEC      A
0023BE F0                MOVX     @DPTR,A
  191:                     strcpy(aCmdBuf+vCmdBufCount, aCmdBuf+vCmdBufCount+1);
0023BF 1231A9            LCALL    ?L?COM0042
0023C2 C001              PUSH     AR1
0023C4 123190            LCALL    ?L?COM003E
0023C7 D001              POP      AR1
0023C9 12057E            LCALL    ?C?STRCPY
  192:                     VT_MoveLeft(1);
0023CC 7F01              MOV      R7,#01H
0023CE 916E              ACALL    _VT_MoveLeft
  193:                     VT_SaveCursorPosition();
0023D0         
0023D0 1230E6            LCALL    ?L?COM0025
0023D3 7A0B              MOV      R2,#HIGH 01000B45H
0023D5 7945              MOV      R1,#LOW 01000B45H
  194:                     VT_Printf("%s ", aCmdBuf+vCmdBufCount);
  195:                     VT_RestoreCursorPosition();
  196:                 }
  197:                 break;
0023D7 807A              SJMP     ?C0123?THREAD_CLI
  198: 
  199:             default:
0023D9         ?C0051?THREAD_CLI:
  200:                 if ((vKey >= 0x20) && (vKey < 0x7F))
0023D9 C3                CLR      C
0023DA E526              MOV      A,vKey+01H
0023DC 9420              SUBB     A,#020H
0023DE E525              MOV      A,vKey
0023E0 6480              XRL      A,#080H
0023E2 9480              SUBB     A,#080H
0023E4 5002              JNC      $ + 4H
0023E6 4148              AJMP     ?C0005?THREAD_CLI
0023E8 E526              MOV      A,vKey+01H
0023EA 947F              SUBB     A,#07FH
0023EC E525              MOV      A,vKey
0023EE 6480              XRL      A,#080H
0023F0 9480              SUBB     A,#080H
0023F2 4002              JC       $ + 4H
0023F4 4148              AJMP     ?C0005?THREAD_CLI
  201:                 {
  202:                     /* visible character */
  203: 
  204:                     UINT8   i = strlen(aCmdBuf);
0023F6 7B01              MOV      R3,#01H
0023F8 7A01              MOV      R2,#HIGH aCmdBuf
0023FA 795B              MOV      R1,#LOW aCmdBuf
0023FC 12002E            LCALL    _strlen
0023FF 8F27              MOV      i,R7
  205: 
  206:                     /* if command buffer not full, record it */
  207:                     if (i <= CLI_CMD_MAX_LEN)
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 37


002401 E527              MOV      A,i
002403 D3                SETB     C
002404 9450              SUBB     A,#050H
002406 4002              JC       $ + 4H
002408 4148              AJMP     ?C0005?THREAD_CLI
  208:                     {
  209:                         aCmdBuf[i+1] = '\0';
00240A 745C              MOV      A,#LOW aCmdBuf+01H
00240C 2F                ADD      A,R7
00240D F582              MOV      DPL,A
00240F E4                CLR      A
002410 3401              ADDC     A,#HIGH aCmdBuf+01H
002412 F583              MOV      DPH,A
002414 E4                CLR      A
002415 F0                MOVX     @DPTR,A
002416         ?C0054?THREAD_CLI:
  210:                         while (i>vCmdBufCount)
002416 9001AC            MOV      DPTR,#vCmdBufCount
002419 E0                MOVX     A,@DPTR
00241A FF                MOV      R7,A
00241B E527              MOV      A,i
00241D D3                SETB     C
00241E 9F                SUBB     A,R7
00241F 4016              JC       ?C0055?THREAD_CLI
  211:                         {
  212:                             aCmdBuf[i] = aCmdBuf[i-1];
002421 745A              MOV      A,#LOW aCmdBuf-01H
002423 2527              ADD      A,i
002425 F582              MOV      DPL,A
002427 E4                CLR      A
002428 3401              ADDC     A,#HIGH aCmdBuf-01H
00242A F583              MOV      DPH,A
00242C E0                MOVX     A,@DPTR
00242D FF                MOV      R7,A
00242E 12319D            LCALL    ?L?COM0041
002431 EF                MOV      A,R7
002432 F0                MOVX     @DPTR,A
  213:                             i--;
002433 1527              DEC      i
  214:                         }
002435 80DF              SJMP     ?C0054?THREAD_CLI
002437         ?C0055?THREAD_CLI:
  215:                         aCmdBuf[i] = vKey;
002437 12319D            LCALL    ?L?COM0041
00243A E526              MOV      A,vKey+01H
00243C F0                MOVX     @DPTR,A
  216:                         vCmdBufCount++;
00243D 123044            LCALL    ?L?COM0011
  217: 
  218:                         VT_Printf("%bc", (UINT8)vKey);
002440 7BFF              MOV      R3,#0FFH
002442 7A0B              MOV      R2,#HIGH 01000B49H
002444 7949              MOV      R1,#LOW 01000B49H
002446 852633            MOV      ?_printf?BYTE+03H,vKey+01H
002449 120700            LCALL    _printf
  219:                         VT_SaveCursorPosition();
00244C 1230E6            LCALL    ?L?COM0025
00244F 7A0B              MOV      R2,#HIGH 01000B42H
002451 7942              MOV      R1,#LOW 01000B42H
002453         
002453 120700            LCALL    _printf
  220:                         VT_Printf("%s", aCmdBuf+vCmdBufCount);
  221:                         VT_RestoreCursorPosition();
002456 F1DC              ACALL    VT_RestoreCursorPosition
  222:                     }
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 38


  223:                 }
  224:                 break;
002458 4148              AJMP     ?C0005?THREAD_CLI
  225:         }
  226:     }
00245A         ?C0006?THREAD_CLI:
  227: 
  228:     /* no command received yet */
  229:     return FALSE;
00245A C3                CLR      C
  230: }
00245B 22                RET      
----- FUNCTION cli_ReadCmd (END) -------


----- FUNCTION _VT_MoveRight (BEGIN) -----
 FILE: '..\cli\vt.c'
   93: void VT_MoveRight(IN UINT8 count)
   94: {
;---- Variable 'count' assigned to Register 'R7' ----
   95:     if (count > 0)
   96:     {
00245C EF                MOV      A,R7
00245D D3                SETB     C
00245E 9400              SUBB     A,#00H
002460 400B              JC       ?C0012?VT
   97:         printf("\x1B[%bdC", count);
   98:     }
002462 7BFF              MOV      R3,#0FFH
002464 7A18              MOV      R2,#HIGH 01001832H
002466 7932              MOV      R1,#LOW 01001832H
002468 8F33              MOV      ?_printf?BYTE+03H,R7
00246A 120700            LCALL    _printf
   99: }
  100: 
00246D         ?C0012?VT:
00246D 22                RET      
----- FUNCTION _VT_MoveRight (END) -------


----- FUNCTION _VT_MoveLeft (BEGIN) -----
 FILE: '..\cli\vt.c'
   67: void VT_MoveLeft(IN UINT8 count)
   68: {
;---- Variable 'count' assigned to Register 'R7' ----
   69:     if (count > 0)
   70:     {
00246E EF                MOV      A,R7
00246F D3                SETB     C
002470 9400              SUBB     A,#00H
002472 400B              JC       ?C0010?VT
   71:         printf("\x1B[%bdD", count);
   72:     }
002474 7BFF              MOV      R3,#0FFH
002476 7A18              MOV      R2,#HIGH 0100182BH
002478 792B              MOV      R1,#LOW 0100182BH
00247A 8F33              MOV      ?_printf?BYTE+03H,R7
00247C 120700            LCALL    _printf
   73: }
   74: 
00247F         ?C0010?VT:
00247F 22                RET      
----- FUNCTION _VT_MoveLeft (END) -------


LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 39


----- FUNCTION cli_ExecCmd (BEGIN) -----
 FILE: '..\cli\thread_cli.c'
  275: static void cli_ExecCmd(void)
  276: {
  277:     UINT8   vLoop;
  278: 
  279:     if (vCmdParamCount == 0)
002480 900014            MOV      DPTR,#vCmdParamCount
002483 E0                MOVX     A,@DPTR
002484 7002              JNZ      $ + 4H
002486 A196              AJMP     ?C0067?THREAD_CLI
  280:     {
  281:         /* empty command */
  282:         return;
  283:     }
002488         ?C0066?THREAD_CLI:
  284: 
  285:     if (strcmp(aCmdParam[0], "?") == 0)
002488 900004            MOV      DPTR,#aCmdParam
00248B E0                MOVX     A,@DPTR
00248C FE                MOV      R6,A
00248D A3                INC      DPTR
00248E E0                MOVX     A,@DPTR
00248F AA06              MOV      R2,AR6
002491 F8                MOV      R0,A
002492 122FA4            LCALL    ?L?COM000F
002495 7A0B              MOV      R2,#HIGH 01000B4DH
002497 794D              MOV      R1,#LOW 01000B4DH
002499 120495            LCALL    ?C?STRCMP
00249C EF                MOV      A,R7
00249D 7004              JNZ      ?C0068?THREAD_CLI
  286:     {
  287:         cli_ShowHelp();
00249F B1E5              ACALL    cli_ShowHelp
  288:     }
0024A1 A192              AJMP     ?C0069?THREAD_CLI
0024A3         ?C0068?THREAD_CLI:
  289:   #if CLI_COMMENT_SUPPORT
  290:     else if (strncmp(aCmdParam[0], CLI_COMMENT_KEYWORD, 1) == 0)
0024A3 122F43            LCALL    ?L?COM0001
0024A6 7529FF            MOV      ?_strncmp?BYTE+03H,#0FFH
0024A9 752A0B            MOV      ?_strncmp?BYTE+04H,#HIGH 01000B4FH
0024AC 752B4F            MOV      ?_strncmp?BYTE+05H,#LOW 01000B4FH
0024AF 752C00            MOV      ?_strncmp?BYTE+06H,#00H
0024B2 752D01            MOV      ?_strncmp?BYTE+07H,#01H
0024B5 12164D            LCALL    _strncmp
0024B8 EF                MOV      A,R7
0024B9 7002              JNZ      $ + 4H
0024BB A192              AJMP     ?C0069?THREAD_CLI
  291:     {
  292:         /* comment, skip it */
  293:     }
0024BD         ?C0070?THREAD_CLI:
  294:   #endif
  295:     else
  296:     {
  297:         /* search & execute command */
  298:         for (vLoop = 0; vLoop < COUNT_OF(aCmdTable); vLoop++)
0024BD E4                CLR      A
0024BE F525              MOV      vLoop,A
0024C0         ?C0072?THREAD_CLI:
  299:         {
  300:             if ((strncmp(aCmdParam[0], aCmdTable[vLoop].pUsage, strlen(aCmdParam[0])) == 0)
0024C0 122F43            LCALL    ?L?COM0001
0024C3 12002E            LCALL    _strlen
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 40


0024C6 8E2C              MOV      ?_strncmp?BYTE+06H,R6
0024C8 8F2D              MOV      ?_strncmp?BYTE+07H,R7
0024CA 122F43            LCALL    ?L?COM0001
0024CD C002              PUSH     AR2
0024CF 12302D            LCALL    ?L?COM000C
0024D2 123079            LCALL    ?L?COM0016
0024D5 7529FF            MOV      ?_strncmp?BYTE+03H,#0FFH
0024D8 8A2A              MOV      ?_strncmp?BYTE+04H,R2
0024DA F52B              MOV      ?_strncmp?BYTE+05H,A
0024DC D002              POP      AR2
0024DE 12164D            LCALL    _strncmp
0024E1 EF                MOV      A,R7
0024E2 6002              JZ       $ + 4H
0024E4 A179              AJMP     ?C0074?THREAD_CLI
0024E6 122F43            LCALL    ?L?COM0001
0024E9 12302A            LCALL    ?L?COM000B
0024EC 123175            LCALL    ?L?COM003B
0024EF 6420              XRL      A,#020H
0024F1 600B              JZ       ?C0076?THREAD_CLI
0024F3 122F43            LCALL    ?L?COM0001
0024F6 12302A            LCALL    ?L?COM000B
0024F9 123175            LCALL    ?L?COM003B
0024FC 707B              JNZ      ?C0074?THREAD_CLI
0024FE         ?C0076?THREAD_CLI:
  301:                 && ((aCmdTable[vLoop].pUsage[strlen(aCmdParam[0])] == ' ')
  302:                     || (aCmdTable[vLoop].pUsage[strlen(aCmdParam[0])] == '\0')))
  303:             {
  304:               #if CLI_CONTINUOUS_CMD_SUPPORT
  305:                 if ((vCmdParamCount > 1)
  306:                     && IsStrEqual(aCmdParam[vCmdParamCount-1], CLI_CONTINUOUS_CMD_KEYWORD))
0024FE 900014            MOV      DPTR,#vCmdParamCount
002501 E0                MOVX     A,@DPTR
002502 FF                MOV      R7,A
002503 D3                SETB     C
002504 9401              SUBB     A,#01H
002506 4068              JC       ?C0077?THREAD_CLI
002508 EF                MOV      A,R7
002509 25E0              ADD      A,ACC
00250B 2402              ADD      A,#LOW aCmdParam-02H
00250D F582              MOV      DPL,A
00250F E4                CLR      A
002510 3400              ADDC     A,#HIGH aCmdParam-02H
002512 F583              MOV      DPH,A
002514 122F8B            LCALL    ?L?COM0018
002517 7001              JNZ      ?C0080?THREAD_CLI
002519 D3                SETB     C
00251A         ?C0080?THREAD_CLI:
00251A         ?C0081?THREAD_CLI:
00251A 4018              JC       ?C0078?THREAD_CLI
00251C 74FF              MOV      A,#0FFH
00251E C3                CLR      C
00251F 7001              JNZ      ?C0082?THREAD_CLI
002521 D3                SETB     C
002522         ?C0082?THREAD_CLI:
002522         ?C0083?THREAD_CLI:
002522 4010              JC       ?C0078?THREAD_CLI
002524 122F9E            LCALL    ?L?COM000E
002527 7A0B              MOV      R2,#HIGH 01000B3AH
002529 793A              MOV      R1,#LOW 01000B3AH
00252B 122F97            LCALL    ?L?COM002C
00252E 7002              JNZ      ?C0084?THREAD_CLI
002530 7F01              MOV      R7,#01H
002532         ?C0084?THREAD_CLI:
002532         ?C0085?THREAD_CLI:
002532 8002              SJMP     ?C0079?THREAD_CLI
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 41


002534         ?C0078?THREAD_CLI:
002534 7F00              MOV      R7,#00H
002536         ?C0079?THREAD_CLI:
002536 EF                MOV      A,R7
002537 6037              JZ       ?C0077?THREAD_CLI
  307:                 {
  308:                     VT_ClearScreen(0);
002539 E4                CLR      A
00253A FF                MOV      R7,A
00253B B1AB              ACALL    _VT_ClearScreen
  309: 
  310:                     for (;;)
00253D         ?C0086?THREAD_CLI:
  311:                     {
  312:                         VT_ClearScreen(1);
00253D 7F01              MOV      R7,#01H
00253F B1AB              ACALL    _VT_ClearScreen
  313: 
  314:                         aCmdTable[vLoop].pExec();
002541 123068            LCALL    ?L?COM0015
002544 F9                MOV      R1,A
002545 120311            LCALL    ?C?ICALL
  315: 
  316:                         /* display status bar */
  317:                         VT_Printf("\n\n\r             ");
002548 7BFF              MOV      R3,#0FFH
00254A 7A0B              MOV      R2,#HIGH 01000B51H
00254C 7951              MOV      R1,#LOW 01000B51H
00254E 120700            LCALL    _printf
  318:                         VT_SetTextAttrib(VT_TEXT_INVERSE);
002551 7F07              MOV      R7,#07H
002553 B1A0              ACALL    _VT_SetTextAttrib
  319:                         VT_Printf("----------    Press 'ESC' to Exit    ----------");
002555 7BFF              MOV      R3,#0FFH
002557 7A0B              MOV      R2,#HIGH 01000B62H
002559 7962              MOV      R1,#LOW 01000B62H
00255B 120700            LCALL    _printf
  320:                         VT_SetTextAttrib(VT_TEXT_NORMAL);
00255E E4                CLR      A
00255F FF                MOV      R7,A
002560 B1A0              ACALL    _VT_SetTextAttrib
  321: 
  322:                         if (VT_ReadKey(1000) == VT_KEY_ESC)
002562 7FE8              MOV      R7,#0E8H
002564 7E03              MOV      R6,#03H
002566 510D              ACALL    __getchar
002568 EF                MOV      A,R7
002569 641B              XRL      A,#01BH
00256B 4E                ORL      A,R6
00256C 70CF              JNZ      ?C0086?THREAD_CLI
  323:                         {
  324:                             break;
00256E 8014              SJMP     ?C0073?THREAD_CLI
  325:                         }
  326:                     }
  327:                 }
002570         ?C0077?THREAD_CLI:
  328:                 else
  329:               #endif
  330:                 {
  331:                     aCmdTable[vLoop].pExec();
002570 123068            LCALL    ?L?COM0015
002573 F9                MOV      R1,A
002574 120311            LCALL    ?C?ICALL
  332:                 }
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 42


  333: 
  334:                 break;
002577 800B              SJMP     ?C0073?THREAD_CLI
  335:             }
  336:         }
002579         ?C0074?THREAD_CLI:
002579 0525              INC      vLoop
00257B E525              MOV      A,vLoop
00257D C3                CLR      C
00257E 940D              SUBB     A,#0DH
002580 5002              JNC      $ + 4H
002582 81C0              AJMP     ?C0072?THREAD_CLI
002584         ?C0073?THREAD_CLI:
  337:         if (vLoop == COUNT_OF(aCmdTable))
002584 E525              MOV      A,vLoop
002586 B40D09            CJNE     A,#0DH,?C0069?THREAD_CLI
  338:         {
  339:             VT_Printf("\n\rInvalid command!");
002589 7BFF              MOV      R3,#0FFH
00258B 7A0B              MOV      R2,#HIGH 01000B92H
00258D 7992              MOV      R1,#LOW 01000B92H
00258F 120700            LCALL    _printf
  340:         }
  341:     }
002592         ?C0069?THREAD_CLI:
  342: 
  343:     /* reset command buffer & parameters */
  344:     aCmdBuf[0] = '\0';
002592 E4                CLR      A
002593 123183            LCALL    ?L?COM003D
  345:     vCmdBufCount = 0;
  346:     vCmdParamCount = 0;
  347: }
002596         ?C0067?THREAD_CLI:
002596 22                RET      
----- FUNCTION cli_ExecCmd (END) -------


----- FUNCTION VT_SaveCursorPosition (BEGIN) -----
 FILE: '..\cli\vt.c'
  299: void VT_SaveCursorPosition(void)
  300: {
  301:     printf("\x1B\x37");
  302: }
002597 7BFF              MOV      R3,#0FFH
002599 7A18              MOV      R2,#HIGH 01001862H
00259B 7962              MOV      R1,#LOW 01001862H
00259D 020700            LJMP     _printf
----- FUNCTION VT_SaveCursorPosition (END) -------


----- FUNCTION _VT_SetTextAttrib (BEGIN) -----
 FILE: '..\cli\vt.c'
  250: void VT_SetTextAttrib(IN VT_TextAttrib attrib)
  251: {
;---- Variable 'attrib' assigned to Register 'R7' ----
  252:     printf("\x1B[%bdm", attrib);
  253: }
0025A0 7BFF              MOV      R3,#0FFH
0025A2 7A18              MOV      R2,#HIGH 01001855H
0025A4 7955              MOV      R1,#LOW 01001855H
0025A6 8F33              MOV      ?_printf?BYTE+03H,R7
0025A8 020700            LJMP     _printf
----- FUNCTION _VT_SetTextAttrib (END) -------

LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 43



----- FUNCTION _VT_ClearScreen (BEGIN) -----
 FILE: '..\cli\vt.c'
  443: void VT_ClearScreen(IN UINT8 clear_mode)
  444: {
;---- Variable 'clear_mode' assigned to Register 'R7' ----
  445:     switch (clear_mode)
  446:     {
0025AB EF                MOV      A,R7
0025AC 14                DEC      A
0025AD 6007              JZ       ?C0043?VT
0025AF 04                INC      A
0025B0 700D              JNZ      ?C0045?VT
  447:         case 0:
  448:             VT_EraseScreen(2);
0025B2         ?C0042?VT:
  449:             VT_SetCursorPosition(0, 0);
0025B2 7F02              MOV      R7,#02H
  450:             break;
  451: 
0025B4 8002              SJMP     ?C0047?VT
  452:         case 1:
0025B6         ?C0043?VT:
  453:             VT_EraseScreen(1);
0025B6 7F01              MOV      R7,#01H
0025B8         
0025B8 F1E5              ACALL    _VT_EraseScreen
  454:             VT_SetCursorPosition(0, 0);
0025BA E4                CLR      A
0025BB FD                MOV      R5,A
0025BC FF                MOV      R7,A
0025BD F1F0              ACALL    _VT_SetCursorPosition
  455: 
  456:         default:
  457:             break;
  458:     }
  459: }
0025BF         ?C0045?VT:
0025BF 22                RET      
----- FUNCTION _VT_ClearScreen (END) -------


----- FUNCTION VT_Init (BEGIN) -----
 FILE: '..\cli\vt.c'
  476: void VT_Init(void)
  477: {
  478:     /* flush Rx FIFO */
  479:     VT_FlushRxFIFO();
0025C0 B1CA              ACALL    VT_FlushRxFIFO
  480: 
  481:     /* set screen to normal display */
  482:     VT_SetTextAttrib(VT_TEXT_NORMAL);
0025C2 E4                CLR      A
0025C3 FF                MOV      R7,A
0025C4 B1A0              ACALL    _VT_SetTextAttrib
  483: 
  484:     /* clear screen */
  485:     VT_ClearScreen(0);
0025C6 E4                CLR      A
0025C7 FF                MOV      R7,A
0025C8 80E1              SJMP     _VT_ClearScreen
----- FUNCTION VT_Init (END) -------


----- FUNCTION VT_FlushRxFIFO (BEGIN) -----
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 44


 FILE: '..\cli\vt.c'
   39: void VT_FlushRxFIFO(void)
   40: {
   41:     BOOL bIntState = DRV_INT_LockUartInterrupt();
   42: 
0025CA 30AC05            JNB      ES0,?C0001?VT
0025CD C2AC              CLR      ES0
0025CF D3                SETB     C
0025D0 8001              SJMP     ?C0002?VT
0025D2         ?C0001?VT:
0025D2 C3                CLR      C
0025D3         ?C0002?VT:
0025D3 9208              MOV      bIntState,C
0025D5         ?C0003?VT:
   43:     while (getchar(NO_PENDING) != -1)
0025D5 E4                CLR      A
0025D6 FF                MOV      R7,A
0025D7 FE                MOV      R6,A
0025D8 510D              ACALL    __getchar
0025DA BEFFF8            CJNE     R6,#0FFH,?C0003?VT
0025DD BFFFF5            CJNE     R7,#0FFH,?C0003?VT
   44:     {}
0025E0         ?C0004?VT:
0025E0         ?C0007?VT:
   45: 
   46:     DRV_INT_UnlockUartInterrupt(bIntState);
0025E0 A208              MOV      C,bIntState
0025E2 92AC              MOV      ES0,C
   47: }
0025E4 22                RET      
----- FUNCTION VT_FlushRxFIFO (END) -------


----- FUNCTION cli_ShowHelp (BEGIN) -----
 FILE: '..\cli\thread_cli.c'
   67: static void cli_ShowHelp(void)
   68: {
   69:     UINT8   vLoop;
   70: 
   71:     VT_Printf("\n\rAvailable Commands :");
0025E5 7BFF              MOV      R3,#0FFH
0025E7 7A0A              MOV      R2,#HIGH 01000AE5H
0025E9 79E5              MOV      R1,#LOW 01000AE5H
0025EB 120700            LCALL    _printf
   72: 
   73:     for (vLoop = 0; vLoop < COUNT_OF(aCmdTable); vLoop++)
0025EE E4                CLR      A
0025EF F526              MOV      vLoop,A
0025F1         ?C0001?THREAD_CLI:
   74:     {
   75:         VT_Printf("\n\r %s", aCmdTable[vLoop].pUsage);
0025F1 E526              MOV      A,vLoop
0025F3 12302F            LCALL    ?L?COM000D
0025F6 123079            LCALL    ?L?COM0016
0025F9 7533FF            MOV      ?_printf?BYTE+03H,#0FFH
0025FC 8A34              MOV      ?_printf?BYTE+04H,R2
0025FE F535              MOV      ?_printf?BYTE+05H,A
002600 7BFF              MOV      R3,#0FFH
002602 7A0A              MOV      R2,#HIGH 01000AFCH
002604 79FC              MOV      R1,#LOW 01000AFCH
002606 120700            LCALL    _printf
   76:     }
002609 0526              INC      vLoop
00260B E526              MOV      A,vLoop
00260D C3                CLR      C
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 45


00260E 940D              SUBB     A,#0DH
002610 40DF              JC       ?C0001?THREAD_CLI
002612         ?C0002?THREAD_CLI:
   77: 
   78:   #if CLI_CONTINUOUS_CMD_SUPPORT
   79:     VT_Printf("\n\r"
002612 7533FF            MOV      ?_printf?BYTE+03H,#0FFH
002615 75340B            MOV      ?_printf?BYTE+04H,#HIGH 01000B3AH
002618 75353A            MOV      ?_printf?BYTE+05H,#LOW 01000B3AH
00261B 7BFF              MOV      R3,#0FFH
00261D 7A0B              MOV      R2,#HIGH 01000B02H
00261F 7902              MOV      R1,#LOW 01000B02H
002621 020700            LJMP     _printf
----- FUNCTION cli_ShowHelp (END) -------


----- FUNCTION CMD_System_Loopback (BEGIN) -----
 FILE: '..\cli\cmd\cmd_system.c'
   60: void CMD_System_Loopback(void)
   61: {
   62:     printf("\n\r Warning: "
   63:            "\n\r  Once entered loopback mode, "
002624 7BFF              MOV      R3,#0FFH
002626 7A15              MOV      R2,#HIGH 01001542H
002628 7942              MOV      R1,#LOW 01001542H
00262A 120700            LCALL    _printf
   64:            "\n\r  only hardware reset can recover to normal mode."
   65:            "\n\r Continue? (Y/N) ");
   66: 
   67:     /* waiting for confirmation */
   68:     for (;;)
00262D         ?C0002?CMD_SYSTEM:
   69:     {
   70:         int vChar = VT_ReadKey(PENDING);
00262D 5109              ACALL    ?L?COM0023
00262F 8E28              MOV      vChar,R6
002631 8F29              MOV      vChar+01H,R7
   71: 
   72:         switch (vChar)
002633 E528              MOV      A,vChar
002635 70F6              JNZ      ?C0002?CMD_SYSTEM
002637 E529              MOV      A,vChar+01H
002639 24B2              ADD      A,#0B2H
00263B 6017              JZ       ?C0009?CMD_SYSTEM
00263D 24E0              ADD      A,#0E0H
00263F 6013              JZ       ?C0009?CMD_SYSTEM
002641 24F5              ADD      A,#0F5H
002643 6004              JZ       ?C0006?CMD_SYSTEM
002645 2420              ADD      A,#020H
002647 70E4              JNZ      ?C0002?CMD_SYSTEM
   73:         {
   74:             case 'Y':
   75:             case 'y':
002649         ?C0006?CMD_SYSTEM:
   76:                 printf("Y\n");
002649 7BFF              MOV      R3,#0FFH
00264B 7A15              MOV      R2,#HIGH 010015B5H
00264D 79B5              MOV      R1,#LOW 010015B5H
00264F 120700            LCALL    _printf
   77:                 goto _loopback;
002652 8009              SJMP     ?C0012?CMD_SYSTEM
   78: 
   79:             case 'N':
   80:             case 'n':
002654         ?C0009?CMD_SYSTEM:
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 46


   81:                 printf("N\n");
002654 7BFF              MOV      R3,#0FFH
002656 7A15              MOV      R2,#HIGH 010015B8H
002658 79B8              MOV      R1,#LOW 010015B8H
00265A 020700            LJMP     _printf
   82:                 return;
   83: 
   84:             default:
   85:                 break;
   86:         }
   87:     }
   88: 
   89:     /* echo loopback data */
   90:   _loopback:
00265D         _loopback:
   91:     for (;;)
00265D         ?C0012?CMD_SYSTEM:
   92:     {
   93:         UINT8 vChar = (UINT8)VT_ReadKey(PENDING);
00265D 5109              ACALL    ?L?COM0023
00265F 8F28              MOV      vChar,R7
   94:         printf(" %.2bX", vChar);
002661 7BFF              MOV      R3,#0FFH
002663 7A15              MOV      R2,#HIGH 010015BBH
002665 79BB              MOV      R1,#LOW 010015BBH
002667 852833            MOV      ?_printf?BYTE+03H,vChar
00266A 120700            LCALL    _printf
   95:     }
00266D 80EE              SJMP     ?C0012?CMD_SYSTEM
----- FUNCTION CMD_System_Loopback (END) -------


----- FUNCTION __trimAll (BEGIN) -----
 FILE: '..\lib\_string.c'
  132: char SEG_XDATA *_trimAll(IN OUT char SEG_XDATA *pStr)
  133: {
00266F 8E28              MOV      pStr,R6
002671 8F29              MOV      pStr+01H,R7
  134:     __nullCheck(pStr);
  135: 
  136:     if (!IsStrEmpty(pStr))
002673 123084            LCALL    ?L?COM001A
002676 7001              JNZ      ?C0018?_STRING
002678 D3                SETB     C
002679         ?C0018?_STRING:
002679         ?C0019?_STRING:
002679 4045              JC       ?C0017?_STRING
  137:     {
  138:         char SEG_XDATA *p;
  139: 
  140:         p = pStr;
00267B 85282A            MOV      p,pStr
00267E 85292B            MOV      p+01H,pStr+01H
002681         ?C0020?_STRING:
  141:         while (*p != '\0')
002681 12321D            LCALL    ?L?COM0051
002684 603A              JZ       ?C0017?_STRING
  142:         {
  143:             /* trim the leading spaces of this string section */
  144:             p = _trimHead(p);
002686 AF2B              MOV      R7,p+01H
002688 AE2A              MOV      R6,p
00268A F108              ACALL    __trimHead
00268C 8E2A              MOV      p,R6
00268E 8F2B              MOV      p+01H,R7
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 47


002690         ?C0022?_STRING:
  145: 
  146:             /* skip the first non-space string section */
  147:             while ((*p != '\0') && !IsSpace(*p))
002690 12321D            LCALL    ?L?COM0051
002693 FF                MOV      R7,A
002694 6013              JZ       ?C0023?_STRING
002696 6420              XRL      A,#020H
002698 600F              JZ       ?C0023?_STRING
00269A EF                MOV      A,R7
00269B 6409              XRL      A,#09H
00269D 600A              JZ       ?C0023?_STRING
  148:             {
  149:                 p++;
00269F 052B              INC      p+01H
0026A1 E52B              MOV      A,p+01H
0026A3 7002              JNZ      ?C0029?_STRING
0026A5 052A              INC      p
0026A7         ?C0029?_STRING:
  150:             }
0026A7 80E7              SJMP     ?C0022?_STRING
0026A9         ?C0023?_STRING:
  151: 
  152:             if (*p == '\0')
0026A9 EF                MOV      A,R7
0026AA 6014              JZ       ?C0017?_STRING
  153:             {
  154:                 break;
  155:             }
0026AC         ?C0024?_STRING:
  156: 
  157:             /* keep this space */
  158:             *p++ = ' ';
0026AC 052B              INC      p+01H
0026AE E52B              MOV      A,p+01H
0026B0 AE2A              MOV      R6,p
0026B2 7002              JNZ      ?C0030?_STRING
0026B4 052A              INC      p
0026B6         ?C0030?_STRING:
0026B6 14                DEC      A
0026B7 F582              MOV      DPL,A
0026B9 8E83              MOV      DPH,R6
0026BB 7420              MOV      A,#020H
0026BD F0                MOVX     @DPTR,A
  159:         }
0026BE 80C1              SJMP     ?C0020?_STRING
  160:     }
0026C0         ?C0017?_STRING:
  161: 
  162:     return _trimTail(pStr);
0026C0 AF29              MOV      R7,pStr+01H
0026C2 AE28              MOV      R6,pStr
;----                  JMP      __trimTail
  163: }
----- FUNCTION __trimAll (END) -------


----- FUNCTION __trimTail (BEGIN) -----
 FILE: '..\lib\_string.c'
   74: char SEG_XDATA *_trimTail(IN OUT char SEG_XDATA *pStr)
   75: {
0026C4 123080            LCALL    ?L?COM0019
0026C7 7001              JNZ      ?C0010?_STRING
0026C9 D3                SETB     C
0026CA         ?C0010?_STRING:
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 48


0026CA         ?C0011?_STRING:
0026CA 4037              JC       ?C0009?_STRING
   76:     __nullCheck(pStr);
   77: 
   78:     if (!IsStrEmpty(pStr))
   79:     {
   80:         char SEG_XDATA *p;
   81: 
   82:         /* point to the start of tailing spaces */
   83:         p = pStr + strlen(pStr) - 1;
0026CC AA2C              MOV      R2,pStr
0026CE A92D              MOV      R1,pStr+01H
0026D0 7B01              MOV      R3,#01H
0026D2 12002E            LCALL    _strlen
0026D5 EF                MOV      A,R7
0026D6 252D              ADD      A,pStr+01H
0026D8 FF                MOV      R7,A
0026D9 EE                MOV      A,R6
0026DA 352C              ADDC     A,pStr
0026DC CF                XCH      A,R7
0026DD 24FF              ADD      A,#0FFH
0026DF F52F              MOV      p+01H,A
0026E1 EF                MOV      A,R7
0026E2 34FF              ADDC     A,#0FFH
0026E4 F52E              MOV      p,A
0026E6         ?C0012?_STRING:
   84:         while (IsSpace(*p))
0026E6 122FAB            LCALL    ?L?COM0034
0026E9 E0                MOVX     A,@DPTR
0026EA FF                MOV      R7,A
0026EB 6420              XRL      A,#020H
0026ED 6004              JZ       ?C0014?_STRING
0026EF EF                MOV      A,R7
0026F0 B4090A            CJNE     A,#09H,?C0013?_STRING
0026F3         ?C0014?_STRING:
   85:         {
   86:             p--;
0026F3 E52F              MOV      A,p+01H
0026F5 152F              DEC      p+01H
0026F7 7002              JNZ      ?C0028?_STRING
0026F9 152E              DEC      p
0026FB         ?C0028?_STRING:
   87:         }
0026FB 80E9              SJMP     ?C0012?_STRING
0026FD         ?C0013?_STRING:
   88: 
   89:         /* mark the tailing spaces to invalid, to remove them */
   90:         *(p+1) = '\0';
0026FD 122FAB            LCALL    ?L?COM0034
002700 A3                INC      DPTR
002701 E4                CLR      A
002702 F0                MOVX     @DPTR,A
   91:     }
002703         ?C0009?_STRING:
   92: 
   93:     return pStr;
002703 AE2C              MOV      R6,pStr
002705 AF2D              MOV      R7,pStr+01H
   94: }
002707 22                RET      
----- FUNCTION __trimTail (END) -------


----- FUNCTION __trimHead (BEGIN) -----
 FILE: '..\lib\_string.c'
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 49


   34: char SEG_XDATA *_trimHead(IN OUT char SEG_XDATA *pStr)
   35: {
002708 123080            LCALL    ?L?COM0019
00270B 7001              JNZ      ?C0002?_STRING
00270D D3                SETB     C
00270E         ?C0002?_STRING:
00270E         ?C0003?_STRING:
00270E 4038              JC       ?C0001?_STRING
   36:     __nullCheck(pStr);
   37: 
   38:     if (!IsStrEmpty(pStr))
   39:     {
   40:         char SEG_XDATA *p;
   41: 
   42:         /* move to the end of leading spaces */
   43:         p = pStr;
002710 852C2E            MOV      p,pStr
002713 852D2F            MOV      p+01H,pStr+01H
002716         ?C0004?_STRING:
   44:         while (IsSpace(*p))
002716 122FAB            LCALL    ?L?COM0034
002719 E0                MOVX     A,@DPTR
00271A FF                MOV      R7,A
00271B 6420              XRL      A,#020H
00271D 6004              JZ       ?C0006?_STRING
00271F EF                MOV      A,R7
002720 B4090A            CJNE     A,#09H,?C0005?_STRING
002723         ?C0006?_STRING:
   45:         {
   46:             p++;
002723 052F              INC      p+01H
002725 E52F              MOV      A,p+01H
002727 7002              JNZ      ?C0026?_STRING
002729 052E              INC      p
00272B         ?C0026?_STRING:
   47:         }
00272B 80E9              SJMP     ?C0004?_STRING
00272D         ?C0005?_STRING:
   48: 
   49:         /* copy the remain string, to remove the leading spaces */
   50:         if (p != pStr)
00272D E52F              MOV      A,p+01H
00272F 652D              XRL      A,pStr+01H
002731 7004              JNZ      ?C0027?_STRING
002733 E52E              MOV      A,p
002735 652C              XRL      A,pStr
002737         ?C0027?_STRING:
002737 600F              JZ       ?C0001?_STRING
   51:         {
   52:             strcpy(pStr, p);
002739 AA2E              MOV      R2,p
00273B A92F              MOV      R1,p+01H
00273D 7B01              MOV      R3,#01H
00273F A82D              MOV      R0,pStr+01H
002741 AC2C              MOV      R4,pStr
002743 7D01              MOV      R5,#01H
002745 12057E            LCALL    ?C?STRCPY
   53:         }
   54:     }
002748         ?C0001?_STRING:
   55: 
   56:     return pStr;
002748 AE2C              MOV      R6,pStr
00274A AF2D              MOV      R7,pStr+01H
   57: }
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 50


00274C 22                RET      
----- FUNCTION __trimHead (END) -------


----- FUNCTION Thread_CLI_Entry (BEGIN) -----
 FILE: '..\cli\thread_cli.c'
  370: OS_HANDLE Thread_CLI_Entry(void)
  371: {
  372:     PT_BEGIN(&vTCB_Cli);
  373: 
00274D 752401            MOV      PT_YIELD_FLAG,#01H
002750         ?C0091?THREAD_CLI:
002750 E513              MOV      A,vTCB_Cli+01H
002752 8512F0            MOV      B,vTCB_Cli
002755 1202E4            LCALL    ?C?ICASE
002758 2764              DW       ?C0094?THREAD_CLI
00275A 0000              DW       00H
00275C 2786              DW       ?C0103?THREAD_CLI
00275E 0184              DW       0184H
002760 0000              DW       00H
002762 279B              DW       ?C0092?THREAD_CLI
  374:     for (;;)
002764         ?C0094?THREAD_CLI:
  375:     {
  376:         if (cli_ReadCmd())
002764 5148              ACALL    cli_ReadCmd
002766 500B              JNC      ?C0099?THREAD_CLI
  377:         {
  378:             /* parse command */
  379:             cli_ParseCmd();
002768 122906            LCALL    cli_ParseCmd
  380: 
  381:             /* execute command */
  382:             cli_ExecCmd();
00276B 9180              ACALL    cli_ExecCmd
  383: 
  384:             /* display command prompt */
  385:             CLI_DISPLAY_CMD_PROMPT();
00276D 12312E            LCALL    ?L?COM0036
002770 120700            LCALL    _printf
  386:         }
002773         ?C0099?THREAD_CLI:
  387: 
  388:         OS_SLEEP_MS(&vTCB_Cli, 5);
002773 E50B              MOV      A,vTickCount+03H
002775 2405              ADD      A,#05H
002777 1230D8            LCALL    ?L?COM0024
00277A 900000            MOV      DPTR,#vEndTick
00277D 1202B2            LCALL    ?C?LSTXDATA
002780 751201            MOV      vTCB_Cli,#01H
002783 751384            MOV      vTCB_Cli+01H,#084H
002786         ?C0103?THREAD_CLI:
002786 E4                CLR      A
002787 F5FE              MOV      PCA0CPH4,A
002789 900000            MOV      DPTR,#vEndTick
00278C 123013            LCALL    ?L?COM0009
00278F 7F00              MOV      R7,#00H
002791 5002              JNC      ?C0105?THREAD_CLI
002793 7F01              MOV      R7,#01H
002795         ?C0105?THREAD_CLI:
002795         ?C0106?THREAD_CLI:
002795 EF                MOV      A,R7
002796 60CC              JZ       ?C0094?THREAD_CLI
002798 7F00              MOV      R7,#00H
00279A 22                RET      
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 51


  389:     }
  390: 
  391:     PT_END(&vTCB_Cli);
00279B         ?C0092?THREAD_CLI:
00279B E4                CLR      A
00279C F524              MOV      PT_YIELD_FLAG,A
00279E F512              MOV      vTCB_Cli,A
0027A0 F513              MOV      vTCB_Cli+01H,A
0027A2 7F03              MOV      R7,#03H
  392: }
0027A4 22                RET      
----- FUNCTION Thread_CLI_Entry (END) -------


----- FUNCTION DRV_VECTOR_Timer2 (BEGIN) -----
 FILE: '..\drv\drv_vector.c'
   38: void DRV_VECTOR_Timer2(void) __interrupt(INTERRUPT_TIMER2)
0027A5 C0E0              PUSH     ACC
0027A7 C0D0              PUSH     PSW
0027A9 75D000            MOV      PSW,#00H
0027AC C004              PUSH     AR4
0027AE C005              PUSH     AR5
0027B0 C006              PUSH     AR6
0027B2 C007              PUSH     AR7
   39: {
   40:     /* clear timeout flag */
   41:     DRV_TIMER_ClearTimeoutFlag();
0027B4 C2CF              CLR      TF2H
   42: 
   43:     /* update tick counter */
   44: 	DRV_TIMER_UpdateTick();
0027B6 AF0B              MOV      R7,vTickCount+03H
0027B8 AE0A              MOV      R6,vTickCount+02H
0027BA AD09              MOV      R5,vTickCount+01H
0027BC AC08              MOV      R4,vTickCount
0027BE EF                MOV      A,R7
0027BF 2401              ADD      A,#01H
0027C1 F50B              MOV      vTickCount+03H,A
0027C3 E4                CLR      A
0027C4 3E                ADDC     A,R6
0027C5 F50A              MOV      vTickCount+02H,A
0027C7 E4                CLR      A
0027C8 3D                ADDC     A,R5
0027C9 F509              MOV      vTickCount+01H,A
0027CB E4                CLR      A
0027CC 3C                ADDC     A,R4
0027CD F508              MOV      vTickCount,A
   45: }
0027CF D007              POP      AR7
0027D1 D006              POP      AR6
0027D3 D005              POP      AR5
0027D5 D004              POP      AR4
0027D7 D0D0              POP      PSW
0027D9 D0E0              POP      ACC
0027DB 32                RETI     
----- FUNCTION DRV_VECTOR_Timer2 (END) -------


----- FUNCTION VT_RestoreCursorPosition (BEGIN) -----
 FILE: '..\cli\vt.c'
  319: void VT_RestoreCursorPosition(void)
  320: {
  321:     printf("\x1B\x38");
  322: }
0027DC 7BFF              MOV      R3,#0FFH
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 52


0027DE 7A18              MOV      R2,#HIGH 01001865H
0027E0 7965              MOV      R1,#LOW 01001865H
0027E2 020700            LJMP     _printf
----- FUNCTION VT_RestoreCursorPosition (END) -------


----- FUNCTION _VT_EraseScreen (BEGIN) -----
 FILE: '..\cli\vt.c'
  188: void VT_EraseScreen(IN UINT8 erase_mode)
  189: {
;---- Variable 'erase_mode' assigned to Register 'R7' ----
  190:     printf("\x1B[%bdJ", erase_mode);
  191: }
0027E5 7BFF              MOV      R3,#0FFH
0027E7 7A18              MOV      R2,#HIGH 0100184EH
0027E9 794E              MOV      R1,#LOW 0100184EH
0027EB 8F33              MOV      ?_printf?BYTE+03H,R7
0027ED 020700            LJMP     _printf
----- FUNCTION _VT_EraseScreen (END) -------


----- FUNCTION _VT_SetCursorPosition (BEGIN) -----
 FILE: '..\cli\vt.c'
  342: void VT_SetCursorPosition(IN UINT8 row, IN UINT8 column)
  343: {
;---- Variable 'column' assigned to Register 'R5' ----
;---- Variable 'row' assigned to Register 'R7' ----
  344:     printf("\x1B[%bd;%bdH", row, column);
  345: }
0027F0 7BFF              MOV      R3,#0FFH
0027F2 7A18              MOV      R2,#HIGH 01001868H
0027F4 7968              MOV      R1,#LOW 01001868H
0027F6 8F33              MOV      ?_printf?BYTE+03H,R7
0027F8 8D34              MOV      ?_printf?BYTE+04H,R5
0027FA 020700            LJMP     _printf
----- FUNCTION _VT_SetCursorPosition (END) -------


----- FUNCTION DRV_IO_Init (BEGIN) -----
 FILE: '..\drv\drv_io.c'
   37: void DRV_IO_Init(void)
   38: {
   39:     /* io internal init */
   40:     P0      = _PORT_INIT(P0);
002800 7580BF            MOV      P0,#0BFH
   41:     P1      = _PORT_INIT(P1);
002803 7590F6            MOV      P1,#0F6H
   42:     P2      = _PORT_INIT(P2);
002806 75A0FF            MOV      P2,#0FFH
   43:     P3      = _PORT_INIT(P3);
002809 75B0FF            MOV      P3,#0FFH
   44:     P0MDIN  = _PORT_MDIN(P0);
00280C 75F17F            MOV      P0MDIN,#07FH
   45:     P1MDIN  = _PORT_MDIN(P1);
00280F 75F2FF            MOV      P1MDIN,#0FFH
   46:     P2MDIN  = _PORT_MDIN(P2);
002812 75F3FB            MOV      P2MDIN,#0FBH
   47:     P3MDIN  = _PORT_MDIN(P3);
002815 75F4FE            MOV      P3MDIN,#0FEH
   48:     P0MDOUT = _PORT_MDOUT(P0);
002818 75A44A            MOV      P0MDOUT,#04AH
   49:     P1MDOUT = _PORT_MDOUT(P1);
00281B 75A558            MOV      P1MDOUT,#058H
   50:     P2MDOUT = _PORT_MDOUT(P2);
00281E 75A60A            MOV      P2MDOUT,#0AH
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 53


   51:     P3MDOUT = _PORT_MDOUT(P3);
002821 E4                CLR      A
002822 F5A7              MOV      P3MDOUT,A
   52: 
   53:     /* default, all pins are skipped for cross-bar */
   54:     P0SKIP = 0xFF;
002824 75D4FF            MOV      P0SKIP,#0FFH
   55:     P1SKIP = 0xFF;
002827 75D5FF            MOV      P1SKIP,#0FFH
   56:     P2SKIP = 0xFF;
00282A 75D6FF            MOV      P2SKIP,#0FFH
   57: 
   58:     /* enable cross-bar */
   59:     XBR0 = 0x00;
00282D F5E1              MOV      XBR0,A
   60:     XBR1 = 0x40;
00282F 75E240            MOV      XBR1,#040H
   61: }
002832 22                RET      
----- FUNCTION DRV_IO_Init (END) -------


----- FUNCTION DRV_PCA_Init (BEGIN) -----
 FILE: '..\drv\drv_pca.c'
   37: void DRV_PCA_Init(void)
   38: {
   39:     UINT8   vPCA0ME = 0x00;
   40: 
;---- Variable 'vPCA0ME' assigned to Register 'R3' ----
002833 E4                CLR      A
002834 FB                MOV      R3,A
   41:     /* PCA channel init */
   42:   #define DECLARE_PCA(_name,_ch,_io,_mode,_init,_desc)                      \
   43:     do {                                                                    \
   44:         DRV_PCA_Write(_name, _init);                                        \
   45:         DRV_PCA_SetMode(_name, _mode);                                      \
   46:                                                                             \
   47:         if (_mode != PCA_MODE_DISABLE)                                      \
   48:         {                                                                   \
   49:             /* force no-skip this PCA channel for GPIO */                   \
   50:             drv_io_SetSkip(_PCA_IO(_name), DISABLE);                        \
   51:             vPCA0ME++;                                                      \
   52:         }                                                                   \
   53:     } while (0);
   54:   #include "cfg_hw_def.h"
   55:   #undef DECLARE_PCA
   56: 
   57:     /* init PCA0:
   58:      *  reset PCA counter;
   59:      *  PCA clock source: defined by DRV_PCA_SOURCE_CLOCK;
   60:      *  enable PCA;
   61:      */
   62:     PCA0H  = 0x00;
   63:     PCA0L  = 0x00;
   64:     PCA0MD = (DRV_PCA_SOURCE_CLOCK<<1);
   65:     PCA0CN = 0x40;
   66: 
   67:     /* enable CEXn at cross-bar */
   68:     XBR1 |= (vPCA0ME&0x7);
   69: }
   70: 
   71: #endif
   72: 
   72: 
   72: 
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 54


002835 75FCFF            MOV      PCA0CPH0,#0FFH
002838         ?C0011?DRV_PCA:
002838 75DA42            MOV      PCA0CPM0,#042H
00283B AFD4              MOV      R7,P0SKIP
00283D EF                MOV      A,R7
00283E 54FD              ANL      A,#0FDH
002840 FF                MOV      R7,A
002841 8FD4              MOV      P0SKIP,R7
002843 0B                INC      R3
002844         ?C0022?DRV_PCA:
002844 E4                CLR      A
002845 F5E9              MOV      PCA0CPL1,A
002847 F5EA              MOV      PCA0CPH1,A
002849         ?C0026?DRV_PCA:
002849 E4                CLR      A
00284A F5DB              MOV      PCA0CPM1,A
00284C         ?C0037?DRV_PCA:
00284C E4                CLR      A
00284D F5EB              MOV      PCA0CPL2,A
00284F F5EC              MOV      PCA0CPH2,A
002851         ?C0041?DRV_PCA:
002851 E4                CLR      A
002852 F5DC              MOV      PCA0CPM2,A
002854         ?C0052?DRV_PCA:
002854 E4                CLR      A
002855 F5ED              MOV      PCA0CPL3,A
002857 F5EE              MOV      PCA0CPH3,A
002859         ?C0056?DRV_PCA:
002859 E4                CLR      A
00285A F5DD              MOV      PCA0CPM3,A
00285C         ?C0047?DRV_PCA:
00285C E4                CLR      A
00285D F5FA              MOV      PCA0H,A
00285F F5F9              MOV      PCA0L,A
002861 75D904            MOV      PCA0MD,#04H
002864 75D840            MOV      PCA0CN,#040H
002867 EB                MOV      A,R3
002868 5407              ANL      A,#07H
00286A 42E2              ORL      XBR1,A
00286C 22                RET      
----- FUNCTION DRV_PCA_Init (END) -------


----- FUNCTION _c2m_WriteDR (BEGIN) -----
 FILE: '..\drv\drv_c2m.c'
  226: static void c2m_WriteDR(UINT8 vData)
  227: {
;---- Variable 'vData' assigned to Register 'R7' ----
  228:     BOOL    bIntState;
  229: 
  230:     c2m_SetIns(0x1);    /* instruction: write data */
00286D D214              SETB     bIns0
00286F C215              CLR      bIns1
  231:     c2m_SetLength(0x1); /* length: 1 byte */
002871 C216              CLR      bLength0
002873 C217              CLR      bLength1
  232:     c2m_SetData(vData);
002875 8F20              MOV      vC2Data,R7
  233: 
  234:     /* lock globally interrupt */
  235:     bIntState = DRV_INT_LockGlobalInterrupt();
002877 30AF05            JNB      EA,?C0355?DRV_C2M
00287A C2AF              CLR      EA
00287C D3                SETB     C
00287D 8001              SJMP     ?C0356?DRV_C2M
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 55


00287F         ?C0355?DRV_C2M:
00287F C3                CLR      C
002880         ?C0356?DRV_C2M:
002880 12305B            LCALL    ?L?COM0014
002883 C297              CLR      IO_C2M_SCL
002885 00                NOP      
002886 00                NOP      
002887 00                NOP      
002888 00                NOP      
002889 1230A2            LCALL    ?L?COM001F
00288C 00                NOP      
00288D 00                NOP      
00288E 00                NOP      
00288F 00                NOP      
002890 F1F1              ACALL    ?L?COM0030
002892 00                NOP      
002893 00                NOP      
002894 00                NOP      
002895 00                NOP      
002896 1231CC            LCALL    ?L?COM0048
002899 00                NOP      
00289A 00                NOP      
00289B 00                NOP      
00289C 00                NOP      
00289D 1231C3            LCALL    ?L?COM0047
0028A0 00                NOP      
0028A1 00                NOP      
0028A2 00                NOP      
0028A3 00                NOP      
0028A4 123214            LCALL    ?L?COM0050
0028A7 00                NOP      
0028A8 00                NOP      
0028A9 00                NOP      
0028AA 00                NOP      
0028AB 12320B            LCALL    ?L?COM004F
0028AE 00                NOP      
0028AF 00                NOP      
0028B0 00                NOP      
0028B1 00                NOP      
0028B2 123202            LCALL    ?L?COM004E
0028B5 00                NOP      
0028B6 00                NOP      
0028B7 00                NOP      
0028B8 00                NOP      
0028B9 1231F9            LCALL    ?L?COM004D
0028BC 00                NOP      
0028BD 00                NOP      
0028BE 00                NOP      
0028BF 00                NOP      
0028C0 1231F0            LCALL    ?L?COM004C
0028C3 00                NOP      
0028C4 00                NOP      
0028C5 00                NOP      
0028C6 00                NOP      
0028C7 1231E7            LCALL    ?L?COM004B
0028CA 00                NOP      
0028CB 00                NOP      
0028CC 00                NOP      
0028CD 00                NOP      
0028CE 1231DE            LCALL    ?L?COM004A
0028D1 00                NOP      
0028D2 00                NOP      
0028D3 00                NOP      
0028D4 00                NOP      
0028D5 1231D5            LCALL    ?L?COM0049
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 56


0028D8 00                NOP      
0028D9 00                NOP      
0028DA 00                NOP      
0028DB 00                NOP      
0028DC 12313E            LCALL    ?L?COM0037
0028DF 00                NOP      
0028E0 D297              SETB     IO_C2M_SCL
0028E2 00                NOP      
0028E3 00                NOP      
  236: 
  237:     c2m_TxStart();      /* tx frame start */
  238:     c2m_TxIns();        /* tx instruction */
  239:     c2m_TxLength();     /* tx length */
  240:     c2m_TxByte();       /* tx address */
  241:     c2m_TxTurnAround(); /* tx turn-around */
  242:     c2m_Wait();         /* wait for target device ready */
0028E4 753827            MOV      _timeout,#027H
0028E7 753910            MOV      _timeout+01H,#010H
0028EA         ?C0557?DRV_C2M:
0028EA 00                NOP      
0028EB 00                NOP      
0028EC C297              CLR      IO_C2M_SCL
0028EE 00                NOP      
0028EF 00                NOP      
0028F0 121CD6            LCALL    ?L?COM0006
0028F3 20000D            JB       bC2Bit0,?C0570?DRV_C2M
0028F6 E539              MOV      A,_timeout+01H
0028F8 1539              DEC      _timeout+01H
0028FA AE38              MOV      R6,_timeout
0028FC 7002              JNZ      ?C1013?DRV_C2M
0028FE 1538              DEC      _timeout
002900         ?C1013?DRV_C2M:
002900 4E                ORL      A,R6
002901 70E7              JNZ      ?C0557?DRV_C2M
  243:     c2m_RxStop();       /* rx frame stop */
002903         ?C0570?DRV_C2M:
002903 023097            LJMP     ?L?COM001D
  244: 
  245:     /* unlock globally interrupt */
  246:     DRV_INT_UnlockGlobalInterrupt(bIntState);
----- FUNCTION _c2m_WriteDR (END) -------


----- FUNCTION cli_ParseCmd (BEGIN) -----
 FILE: '..\cli\thread_cli.c'
  233: static void cli_ParseCmd(void)
  234: {
  235:     char SEG_XDATA *ptr;
  236: 
  237:     ptr = (char SEG_XDATA *)aCmdBuf;
002906 7E01              MOV      R6,#HIGH aCmdBuf
002908 7F5B              MOV      R7,#LOW aCmdBuf
;---- Variable 'ptr' assigned to Register 'R6/R7' ----
  238:     vCmdParamCount = 0;
00290A E4                CLR      A
00290B 900014            MOV      DPTR,#vCmdParamCount
00290E F0                MOVX     @DPTR,A
00290F         ?C0056?THREAD_CLI:
  239:     while (*ptr != '\0')
00290F 8F82              MOV      DPL,R7
002911 8E83              MOV      DPH,R6
002913 E0                MOVX     A,@DPTR
002914 6057              JZ       ?C0061?THREAD_CLI
  240:     {
002916         ?C0058?THREAD_CLI:
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 57


  241:         /* skip spaces */
  242:         while (*ptr == ' ')
002916 8F82              MOV      DPL,R7
002918 8E83              MOV      DPH,R6
00291A E0                MOVX     A,@DPTR
00291B FD                MOV      R5,A
00291C B42007            CJNE     A,#020H,?C0059?THREAD_CLI
  243:         {
  244:             ptr++;
00291F 0F                INC      R7
002920 BF0001            CJNE     R7,#00H,?C0116?THREAD_CLI
002923 0E                INC      R6
002924         ?C0116?THREAD_CLI:
  245:         }
002924 80F0              SJMP     ?C0058?THREAD_CLI
002926         ?C0059?THREAD_CLI:
  246: 
  247:         if (*ptr == '\0')
002926 ED                MOV      A,R5
002927 6044              JZ       ?C0061?THREAD_CLI
  248:         {
  249:             return;
  250:         }
002929         ?C0060?THREAD_CLI:
  251: 
  252:         aCmdParam[vCmdParamCount++] = ptr;
002929 900014            MOV      DPTR,#vCmdParamCount
00292C E0                MOVX     A,@DPTR
00292D FD                MOV      R5,A
00292E 04                INC      A
00292F F0                MOVX     @DPTR,A
002930 ED                MOV      A,R5
002931 25E0              ADD      A,ACC
002933 2404              ADD      A,#LOW aCmdParam
002935 F582              MOV      DPL,A
002937 E4                CLR      A
002938 3400              ADDC     A,#HIGH aCmdParam
00293A F583              MOV      DPH,A
00293C EE                MOV      A,R6
00293D F0                MOVX     @DPTR,A
00293E A3                INC      DPTR
00293F EF                MOV      A,R7
002940 F0                MOVX     @DPTR,A
002941         ?C0062?THREAD_CLI:
  253:         while (*ptr != ' ')
002941 8F82              MOV      DPL,R7
002943 8E83              MOV      DPH,R6
002945 E0                MOVX     A,@DPTR
002946 FD                MOV      R5,A
002947 6420              XRL      A,#020H
002949 600A              JZ       ?C0063?THREAD_CLI
  254:         {
  255:             if (*ptr == '\0')
00294B ED                MOV      A,R5
00294C 601F              JZ       ?C0061?THREAD_CLI
  256:             {
  257:                 return;
  258:             }
00294E         ?C0064?THREAD_CLI:
  259: 
  260:             ptr++;
00294E 0F                INC      R7
00294F BF0001            CJNE     R7,#00H,?C0117?THREAD_CLI
002952 0E                INC      R6
002953         ?C0117?THREAD_CLI:
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 58


  261:         }
002953 80EC              SJMP     ?C0062?THREAD_CLI
002955         ?C0063?THREAD_CLI:
  262: 
  263:         /* add end character to this parameter */
  264:         *ptr++ = '\0';
002955 0F                INC      R7
002956 EF                MOV      A,R7
002957 AC06              MOV      R4,AR6
002959 7001              JNZ      ?C0118?THREAD_CLI
00295B 0E                INC      R6
00295C         ?C0118?THREAD_CLI:
00295C 14                DEC      A
00295D F582              MOV      DPL,A
00295F 8C83              MOV      DPH,R4
002961 E4                CLR      A
002962 F0                MOVX     @DPTR,A
  265: 
  266:         if (vCmdParamCount > CLI_CMD_MAX_PARAM)
002963 900014            MOV      DPTR,#vCmdParamCount
002966 E0                MOVX     A,@DPTR
002967 D3                SETB     C
002968 9408              SUBB     A,#08H
00296A 40A3              JC       ?C0056?THREAD_CLI
  267:         {
  268:             break;
00296C 22                RET      
  269:         }
  270:     }
  271: 
  272:     return;
  273: }
00296D         ?C0061?THREAD_CLI:
00296D 22                RET      
----- FUNCTION cli_ParseCmd (END) -------


----- FUNCTION Thread_CLI_Init (BEGIN) -----
 FILE: '..\cli\thread_cli.c'
  409: void Thread_CLI_Init(void)
  410: {
  411:     PT_INIT(&vTCB_Cli);
  412: 
00296E E4                CLR      A
00296F F512              MOV      vTCB_Cli,A
002971 F513              MOV      vTCB_Cli+01H,A
  413:     /* reset command buffer & parameters */
  414:     aCmdBuf[0] = '\0';
002973 123183            LCALL    ?L?COM003D
  415:     vCmdBufCount = 0;
  416:     vCmdParamCount = 0;
  417: 
  418:     /* init VT */
  419:     VT_Init();
002976 1225C0            LCALL    VT_Init
  420: 
  421:   #if CLI_CMD_HISTORY_SUPPORT
  422:     cli_HistoryInit();
002979 7E01              MOV      R6,#01H
00297B 7F44              MOV      R7,#044H
00297D 7D00              MOV      R5,#00H
00297F 7B01              MOV      R3,#01H
002981 7A00              MOV      R2,#HIGH aHistoryBuf
002983 7917              MOV      R1,#LOW aHistoryBuf
002985 12059B            LCALL    ?C?MEMSET
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 59


002988 E4                CLR      A
002989 900015            MOV      DPTR,#vHistoryLatest
00298C F0                MOVX     @DPTR,A
00298D A3                INC      DPTR
00298E F0                MOVX     @DPTR,A
  423:   #endif
  424: 
  425:   #if CLI_BANNER_SUPPORT
  426:     /* display banner */
  427:     CLI_DISPLAY_BANNER();
00298F F1D4              ACALL    ?L?COM0040
002991 7A0B              MOV      R2,#HIGH 01000BFCH
002993 79FC              MOV      R1,#LOW 01000BFCH
002995 9001E8            MOV      DPTR,#__sig+08H
002998 E4                CLR      A
002999 93                MOVC     A,@A+DPTR
00299A F533              MOV      ?_printf?BYTE+03H,A
00299C A3                INC      DPTR
00299D E4                CLR      A
00299E 93                MOVC     A,@A+DPTR
00299F F534              MOV      ?_printf?BYTE+04H,A
0029A1 A3                INC      DPTR
0029A2 E4                CLR      A
0029A3 93                MOVC     A,@A+DPTR
0029A4 F535              MOV      ?_printf?BYTE+05H,A
0029A6 A3                INC      DPTR
0029A7 E4                CLR      A
0029A8 93                MOVC     A,@A+DPTR
0029A9 F536              MOV      ?_printf?BYTE+06H,A
0029AB A3                INC      DPTR
0029AC E4                CLR      A
0029AD 93                MOVC     A,@A+DPTR
0029AE F537              MOV      ?_printf?BYTE+07H,A
0029B0 A3                INC      DPTR
0029B1 E4                CLR      A
0029B2 93                MOVC     A,@A+DPTR
0029B3 F538              MOV      ?_printf?BYTE+08H,A
0029B5 A3                INC      DPTR
0029B6 E4                CLR      A
0029B7 93                MOVC     A,@A+DPTR
0029B8 F539              MOV      ?_printf?BYTE+09H,A
0029BA A3                INC      DPTR
0029BB E4                CLR      A
0029BC 93                MOVC     A,@A+DPTR
0029BD F53A              MOV      ?_printf?BYTE+0AH,A
0029BF 120700            LCALL    _printf
0029C2 7BFF              MOV      R3,#0FFH
0029C4 7A0C              MOV      R2,#HIGH 01000C40H
0029C6 7940              MOV      R1,#LOW 01000C40H
0029C8 120700            LCALL    _printf
0029CB F1D4              ACALL    ?L?COM0040
0029CD 7A0C              MOV      R2,#HIGH 01000C6EH
0029CF 796E              MOV      R1,#LOW 01000C6EH
0029D1 120700            LCALL    _printf
  428:   #endif
  429: 
  430:     /* display command prompt */
  431:     CLI_DISPLAY_CMD_PROMPT();
0029D4 12312E            LCALL    ?L?COM0036
0029D7 020700            LJMP     _printf
----- FUNCTION Thread_CLI_Init (END) -------


----- FUNCTION CMD_IO_Write (BEGIN) -----
 FILE: '..\cli\cmd\cmd_io.c'
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 60


   39: void CMD_IO_Write(void)
   40: {
   41:     UINT8   vPort;
   42:     UINT8   vBit;
   43:     UINT8   vValue;
   44: 
   45:     if (CLI_vParam != 4)
0029DA 900014            MOV      DPTR,#vCmdParamCount
0029DD E0                MOVX     A,@DPTR
0029DE 6404              XRL      A,#04H
0029E0 6002              JZ       ?C0001?CMD_IO
   46:     {
   47:         printf("\n\rInvalid Parameter!");
0029E2 8043              SJMP     ?C0046?CMD_IO
   48:         return;
   49:     }
0029E4         ?C0001?CMD_IO:
   50: 
   51:     vPort  = (UINT8)strtoul(CLI_aParam[1], NULL, 0);
0029E4 900006            MOV      DPTR,#aCmdParam+02H
0029E7 F146              ACALL    ?L?COM0002
0029E9 C003              PUSH     AR3
0029EB F150              ACALL    ?L?COM0003
0029ED D003              POP      AR3
0029EF 120EBA            LCALL    _strtoul
0029F2 8F28              MOV      vPort,R7
   52:     vBit   = (UINT8)strtoul(CLI_aParam[2], NULL, 0);
0029F4 900008            MOV      DPTR,#aCmdParam+04H
0029F7 F146              ACALL    ?L?COM0002
0029F9 C003              PUSH     AR3
0029FB F150              ACALL    ?L?COM0003
0029FD D003              POP      AR3
0029FF 120EBA            LCALL    _strtoul
002A02 8F29              MOV      vBit,R7
   53:     vValue = (UINT8)strtoul(CLI_aParam[3], NULL, 0);
002A04 90000A            MOV      DPTR,#aCmdParam+06H
002A07 F146              ACALL    ?L?COM0002
002A09 C003              PUSH     AR3
002A0B F150              ACALL    ?L?COM0003
002A0D D003              POP      AR3
002A0F 120EBA            LCALL    _strtoul
002A12 8F2A              MOV      vValue,R7
   54: 
   55:     if ((vPort > IO_PORT_MAX) || (vBit > IO_BIT_MAX) || (vValue > 1))
002A14 E528              MOV      A,vPort
002A16 D3                SETB     C
002A17 9403              SUBB     A,#03H
002A19 500C              JNC      ?C0004?CMD_IO
002A1B E529              MOV      A,vBit
002A1D 9407              SUBB     A,#07H
002A1F 5006              JNC      ?C0004?CMD_IO
002A21 E52A              MOV      A,vValue
002A23 9401              SUBB     A,#01H
002A25 4008              JC       ?C0003?CMD_IO
002A27         ?C0004?CMD_IO:
   56:     {
   57:         printf("\n\rInvalid Parameter!");
002A27         
002A27 7BFF              MOV      R3,#0FFH
002A29 7A17              MOV      R2,#HIGH 010017D3H
002A2B 79D3              MOV      R1,#LOW 010017D3H
002A2D 41EF              AJMP     ?C0047?CMD_IO
   58:         return;
   59:     }
002A2F         ?C0003?CMD_IO:
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 61


   60: 
   61:     switch (vPort)
002A2F E528              MOV      A,vPort
002A31 14                DEC      A
002A32 6037              JZ       ?C0013?CMD_IO
002A34 14                DEC      A
002A35 605D              JZ       ?C0017?CMD_IO
002A37 14                DEC      A
002A38 7002              JNZ      $ + 4H
002A3A 41BD              AJMP     ?C0021?CMD_IO
002A3C 2403              ADD      A,#03H
002A3E 6002              JZ       $ + 4H
002A40 41E4              AJMP     ?C0005?CMD_IO
   62:     {
   63:       #if (IO_PORT_MAX >= 0)
   64:         case 0 : drv_io_Write(P0, vBit, vValue); break;
002A42         ?C0009?CMD_IO:
002A42 F164              ACALL    ?L?COM0035
002A44 8005              SJMP     ?C0037?CMD_IO
002A46         ?C0036?CMD_IO:
002A46 C3                CLR      C
002A47 33                RLC      A
002A48 CE                XCH      A,R6
002A49 33                RLC      A
002A4A CE                XCH      A,R6
002A4B         ?C0037?CMD_IO:
002A4B D8F9              DJNZ     R0,?C0036?CMD_IO
002A4D F4                CPL      A
002A4E FF                MOV      R7,A
002A4F AD80              MOV      R5,P0
002A51 F175              ACALL    ?L?COM002E
002A53 C004              PUSH     AR4
002A55 C005              PUSH     AR5
002A57 C006              PUSH     AR6
002A59 C007              PUSH     AR7
002A5B F16C              ACALL    ?L?COM0029
002A5D D003              POP      AR3
002A5F D002              POP      AR2
002A61 D001              POP      AR1
002A63 D000              POP      AR0
002A65 F17E              ACALL    ?L?COM0028
002A67 8F80              MOV      P0,R7
002A69 8079              SJMP     ?C0005?CMD_IO
   65:       #endif
   66:       #if (IO_PORT_MAX >= 1)
   67:         case 1 : drv_io_Write(P1, vBit, vValue); break;
002A6B         ?C0013?CMD_IO:
002A6B F164              ACALL    ?L?COM0035
002A6D 8005              SJMP     ?C0039?CMD_IO
002A6F         ?C0038?CMD_IO:
002A6F C3                CLR      C
002A70 33                RLC      A
002A71 CE                XCH      A,R6
002A72 33                RLC      A
002A73 CE                XCH      A,R6
002A74         ?C0039?CMD_IO:
002A74 D8F9              DJNZ     R0,?C0038?CMD_IO
002A76 F4                CPL      A
002A77 FF                MOV      R7,A
002A78 AD90              MOV      R5,P1
002A7A F175              ACALL    ?L?COM002E
002A7C C004              PUSH     AR4
002A7E C005              PUSH     AR5
002A80 C006              PUSH     AR6
002A82 C007              PUSH     AR7
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 62


002A84 F16C              ACALL    ?L?COM0029
002A86 D003              POP      AR3
002A88 D002              POP      AR2
002A8A D001              POP      AR1
002A8C D000              POP      AR0
002A8E F17E              ACALL    ?L?COM0028
002A90 8F90              MOV      P1,R7
002A92 8050              SJMP     ?C0005?CMD_IO
   68:       #endif
   69:       #if (IO_PORT_MAX >= 2)
   70:         case 2 : drv_io_Write(P2, vBit, vValue); break;
002A94         ?C0017?CMD_IO:
002A94 F164              ACALL    ?L?COM0035
002A96 8005              SJMP     ?C0041?CMD_IO
002A98         ?C0040?CMD_IO:
002A98 C3                CLR      C
002A99 33                RLC      A
002A9A CE                XCH      A,R6
002A9B 33                RLC      A
002A9C CE                XCH      A,R6
002A9D         ?C0041?CMD_IO:
002A9D D8F9              DJNZ     R0,?C0040?CMD_IO
002A9F F4                CPL      A
002AA0 FF                MOV      R7,A
002AA1 ADA0              MOV      R5,P2
002AA3 F175              ACALL    ?L?COM002E
002AA5 C004              PUSH     AR4
002AA7 C005              PUSH     AR5
002AA9 C006              PUSH     AR6
002AAB C007              PUSH     AR7
002AAD F16C              ACALL    ?L?COM0029
002AAF D003              POP      AR3
002AB1 D002              POP      AR2
002AB3 D001              POP      AR1
002AB5 D000              POP      AR0
002AB7 F17E              ACALL    ?L?COM0028
002AB9 8FA0              MOV      P2,R7
002ABB 8027              SJMP     ?C0005?CMD_IO
   71:       #endif
   72:       #if (IO_PORT_MAX >= 3)
   73:         case 3 : drv_io_Write(P3, vBit, vValue); break;
002ABD         ?C0021?CMD_IO:
002ABD F164              ACALL    ?L?COM0035
002ABF 8005              SJMP     ?C0043?CMD_IO
002AC1         ?C0042?CMD_IO:
002AC1 C3                CLR      C
002AC2 33                RLC      A
002AC3 CE                XCH      A,R6
002AC4 33                RLC      A
002AC5 CE                XCH      A,R6
002AC6         ?C0043?CMD_IO:
002AC6 D8F9              DJNZ     R0,?C0042?CMD_IO
002AC8 F4                CPL      A
002AC9 FF                MOV      R7,A
002ACA ADB0              MOV      R5,P3
002ACC F175              ACALL    ?L?COM002E
002ACE C004              PUSH     AR4
002AD0 C005              PUSH     AR5
002AD2 C006              PUSH     AR6
002AD4 C007              PUSH     AR7
002AD6 F16C              ACALL    ?L?COM0029
002AD8 D003              POP      AR3
002ADA D002              POP      AR2
002ADC D001              POP      AR1
002ADE D000              POP      AR0
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 63


002AE0 F17E              ACALL    ?L?COM0028
002AE2 8FB0              MOV      P3,R7
   74:       #endif
   75:       #if (IO_PORT_MAX >= 4)
   76:         case 4 : drv_io_Write(P4, vBit, vValue); break;
   77:       #endif
   78:         default: break;
   79:     }
002AE4         ?C0005?CMD_IO:
   80: 
   81:     printf("\n\r IO Write P%bd.%bd=%bd ", vPort, vBit, vValue);
002AE4 7BFF              MOV      R3,#0FFH
002AE6 7A17              MOV      R2,#HIGH 010017E8H
002AE8 79E8              MOV      R1,#LOW 010017E8H
002AEA F15D              ACALL    ?L?COM003C
002AEC 852A35            MOV      ?_printf?BYTE+05H,vValue
002AEF         
002AEF 020700            LJMP     _printf
   82: }
----- FUNCTION CMD_IO_Write (END) -------


----- FUNCTION CMD_IO_Monitor (BEGIN) -----
 FILE: '..\cli\cmd\cmd_io.c'
   99: void CMD_IO_Monitor(void)
  100: {
  101:     UINT8   vPort;
  102:     UINT8   vBit;
  103: 
  104:     printf("\n\r All IO Read Status:");
002AF2 7BFF              MOV      R3,#0FFH
002AF4 7A18              MOV      R2,#HIGH 01001802H
002AF6 7902              MOV      R1,#LOW 01001802H
002AF8 120700            LCALL    _printf
  105:     for (vPort = 0; vPort <= IO_PORT_MAX; vPort++)
002AFB E4                CLR      A
002AFC F528              MOV      vPort,A
002AFE         ?C0023?CMD_IO:
  106:     {
  107:         UINT8   vPortVal;
  108: 
  109:         printf("\n\r");
002AFE 7BFF              MOV      R3,#0FFH
002B00 7A18              MOV      R2,#HIGH 01001819H
002B02 7919              MOV      R1,#LOW 01001819H
002B04 120700            LCALL    _printf
  110: 
  111:         switch (vPort)
002B07 E528              MOV      A,vPort
002B09 14                DEC      A
002B0A 600F              JZ       ?C0028?CMD_IO
002B0C 14                DEC      A
002B0D 6011              JZ       ?C0029?CMD_IO
002B0F 14                DEC      A
002B10 6013              JZ       ?C0030?CMD_IO
002B12 2403              ADD      A,#03H
002B14 7014              JNZ      ?C0031?CMD_IO
  112:         {
  113:           #if (IO_PORT_MAX >= 0)
  114:             case 0 : vPortVal = P0;   break;
002B16         ?C0027?CMD_IO:
002B16 85802A            MOV      vPortVal,P0
002B19 8012              SJMP     ?C0026?CMD_IO
  115:           #endif
  116:           #if (IO_PORT_MAX >= 1)
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 64


  117:             case 1 : vPortVal = P1;   break;
002B1B         ?C0028?CMD_IO:
002B1B 85902A            MOV      vPortVal,P1
002B1E 800D              SJMP     ?C0026?CMD_IO
  118:           #endif
  119:           #if (IO_PORT_MAX >= 2)
  120:             case 2 : vPortVal = P2;   break;
002B20         ?C0029?CMD_IO:
002B20 85A02A            MOV      vPortVal,P2
002B23 8008              SJMP     ?C0026?CMD_IO
  121:           #endif
  122:           #if (IO_PORT_MAX >= 3)
  123:             case 3 : vPortVal = P3;   break;
002B25         ?C0030?CMD_IO:
002B25 85B02A            MOV      vPortVal,P3
002B28 8003              SJMP     ?C0026?CMD_IO
  124:           #endif
  125:           #if (IO_PORT_MAX >= 4)
  126:             case 4 : vPortVal = P4;   break;
  127:           #endif
  128:             default: vPortVal = 0x00; break;
002B2A         ?C0031?CMD_IO:
002B2A E4                CLR      A
002B2B F52A              MOV      vPortVal,A
  129:         }
002B2D         ?C0026?CMD_IO:
  130: 
  131:         for (vBit = 0; vBit <= IO_BIT_MAX; vBit++)
002B2D E4                CLR      A
002B2E F529              MOV      vBit,A
002B30         ?C0032?CMD_IO:
  132:         {
  133:             printf("  P%bd.%bd=%bd", vPort, vBit, (UINT8)READ_BIT(vPortVal, vBit));
002B30 7BFF              MOV      R3,#0FFH
002B32 7A18              MOV      R2,#HIGH 0100181CH
002B34 791C              MOV      R1,#LOW 0100181CH
002B36 F15D              ACALL    ?L?COM003C
002B38 AF29              MOV      R7,vBit
002B3A E52A              MOV      A,vPortVal
002B3C A807              MOV      R0,AR7
002B3E 08                INC      R0
002B3F 8002              SJMP     ?C0045?CMD_IO
002B41         ?C0044?CMD_IO:
002B41 C3                CLR      C
002B42 13                RRC      A
002B43         ?C0045?CMD_IO:
002B43 D8FC              DJNZ     R0,?C0044?CMD_IO
002B45 13                RRC      A
002B46 E4                CLR      A
002B47 33                RLC      A
002B48 F535              MOV      ?_printf?BYTE+05H,A
002B4A 120700            LCALL    _printf
  134:         }
002B4D 0529              INC      vBit
002B4F E529              MOV      A,vBit
002B51 D3                SETB     C
002B52 9407              SUBB     A,#07H
002B54 40DA              JC       ?C0032?CMD_IO
  135:     }
002B56         ?C0025?CMD_IO:
002B56 0528              INC      vPort
002B58 E528              MOV      A,vPort
002B5A D3                SETB     C
002B5B 9403              SUBB     A,#03H
002B5D 409F              JC       ?C0023?CMD_IO
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 65


  136: }
002B5F 22                RET      
----- FUNCTION CMD_IO_Monitor (END) -------


----- FUNCTION CMD_Mem_Read (BEGIN) -----
 FILE: '..\cli\cmd\cmd_mem.c'
   39: void CMD_Mem_Read(void)
   40: {
   41:     BOOL    bCode;
   42:     UINT16  vAddr;
   43:     UINT16  vCount;
   44:     UINT16  vLoop;
   45: 
   46:     if ((CLI_vParam < 3) || (CLI_vParam > 4))
002B60 900014            MOV      DPTR,#vCmdParamCount
002B63 E0                MOVX     A,@DPTR
002B64 FF                MOV      R7,A
002B65 C3                CLR      C
002B66 9403              SUBB     A,#03H
002B68 4050              JC       ?C0073?CMD_MEM
002B6A EF                MOV      A,R7
002B6B D3                SETB     C
002B6C 9404              SUBB     A,#04H
002B6E 4002              JC       ?C0001?CMD_MEM
002B70         ?C0002?CMD_MEM:
   47:     {
   48:         printf("\n\rInvalid Parameter!");
002B70 8048              SJMP     ?C0073?CMD_MEM
   49:         return;
   50:     }
002B72         ?C0001?CMD_MEM:
   51: 
   52:     if (IsStrEqual(CLI_aParam[1], "code"))
002B72 F188              ACALL    ?L?COM0017
002B74 7001              JNZ      ?C0007?CMD_MEM
002B76 D3                SETB     C
002B77         ?C0007?CMD_MEM:
002B77         ?C0008?CMD_MEM:
002B77 4012              JC       ?C0005?CMD_MEM
002B79 74FF              MOV      A,#0FFH
002B7B C3                CLR      C
002B7C 7001              JNZ      ?C0009?CMD_MEM
002B7E D3                SETB     C
002B7F         ?C0009?CMD_MEM:
002B7F         ?C0010?CMD_MEM:
002B7F 400A              JC       ?C0005?CMD_MEM
002B81 F19E              ACALL    ?L?COM000E
002B83 F193              ACALL    ?L?COM002B
002B85 7002              JNZ      ?C0011?CMD_MEM
002B87 7F01              MOV      R7,#01H
002B89         ?C0011?CMD_MEM:
002B89         ?C0012?CMD_MEM:
002B89 8002              SJMP     ?C0006?CMD_MEM
002B8B         ?C0005?CMD_MEM:
002B8B 7F00              MOV      R7,#00H
002B8D         ?C0006?CMD_MEM:
002B8D EF                MOV      A,R7
002B8E 6004              JZ       ?C0004?CMD_MEM
   53:     {
   54:         bCode = TRUE;
002B90 D208              SETB     bCode
   55:     }
002B92 802F              SJMP     ?C0013?CMD_MEM
002B94         ?C0004?CMD_MEM:
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 66


   56:     else if (IsStrEqual(CLI_aParam[1], "xdata"))
002B94 F188              ACALL    ?L?COM0017
002B96 7001              JNZ      ?C0017?CMD_MEM
002B98 D3                SETB     C
002B99         ?C0017?CMD_MEM:
002B99         ?C0018?CMD_MEM:
002B99 4016              JC       ?C0015?CMD_MEM
002B9B 74FF              MOV      A,#0FFH
002B9D C3                CLR      C
002B9E 7001              JNZ      ?C0019?CMD_MEM
002BA0 D3                SETB     C
002BA1         ?C0019?CMD_MEM:
002BA1         ?C0020?CMD_MEM:
002BA1 400E              JC       ?C0015?CMD_MEM
002BA3 F19E              ACALL    ?L?COM000E
002BA5 7A19              MOV      R2,#HIGH 01001913H
002BA7 7913              MOV      R1,#LOW 01001913H
002BA9 F197              ACALL    ?L?COM002C
002BAB 7002              JNZ      ?C0021?CMD_MEM
002BAD 7F01              MOV      R7,#01H
002BAF         ?C0021?CMD_MEM:
002BAF         ?C0022?CMD_MEM:
002BAF 8002              SJMP     ?C0016?CMD_MEM
002BB1         ?C0015?CMD_MEM:
002BB1 7F00              MOV      R7,#00H
002BB3         ?C0016?CMD_MEM:
002BB3 EF                MOV      A,R7
002BB4 6004              JZ       ?C0014?CMD_MEM
   57:     {
   58:         bCode = FALSE;
002BB6 C208              CLR      bCode
   59:     }
002BB8 8009              SJMP     ?C0013?CMD_MEM
002BBA         ?C0014?CMD_MEM:
   60:     else
   61:     {
   62:         printf("\n\rInvalid Parameter!");
002BBA         
002BBA 7BFF              MOV      R3,#0FFH
002BBC 7A18              MOV      R2,#HIGH 010018F9H
002BBE 79F9              MOV      R1,#LOW 010018F9H
002BC0 020700            LJMP     _printf
   63:         return;
   64:     }
002BC3         ?C0013?CMD_MEM:
   65: 
   66:     vAddr = (UINT16)strtoul(CLI_aParam[2], NULL, 0);
002BC3 900008            MOV      DPTR,#aCmdParam+04H
002BC6 F146              ACALL    ?L?COM0002
002BC8 C003              PUSH     AR3
002BCA F150              ACALL    ?L?COM0003
002BCC D003              POP      AR3
002BCE F1C0              ACALL    ?L?COM003F
   67: 
   68:     if (CLI_vParam == 4)
002BD0 900014            MOV      DPTR,#vCmdParamCount
002BD3 E0                MOVX     A,@DPTR
002BD4 B40414            CJNE     A,#04H,?C0024?CMD_MEM
   69:     {
   70:         vCount = (UINT16)strtoul(CLI_aParam[3], NULL, 0);
002BD7 90000A            MOV      DPTR,#aCmdParam+06H
002BDA F146              ACALL    ?L?COM0002
002BDC C003              PUSH     AR3
002BDE F150              ACALL    ?L?COM0003
002BE0 D003              POP      AR3
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 67


002BE2 120EBA            LCALL    _strtoul
002BE5 8E2A              MOV      vCount,R6
002BE7 8F2B              MOV      vCount+01H,R7
   71:     }
002BE9 8006              SJMP     ?C0025?CMD_MEM
002BEB         ?C0024?CMD_MEM:
   72:     else
   73:     {
   74:         vCount = 1;
002BEB 752A00            MOV      vCount,#00H
002BEE 752B01            MOV      vCount+01H,#01H
   75:     }
002BF1         ?C0025?CMD_MEM:
   76: 
   77:     for (vLoop = 0; vLoop < vCount; vLoop++)
002BF1 E4                CLR      A
002BF2 F52C              MOV      vLoop,A
002BF4 F52D              MOV      vLoop+01H,A
002BF6         ?C0026?CMD_MEM:
002BF6 C3                CLR      C
002BF7 E52D              MOV      A,vLoop+01H
002BF9 952B              SUBB     A,vCount+01H
002BFB E52C              MOV      A,vLoop
002BFD 952A              SUBB     A,vCount
002BFF 504E              JNC      ?C0003?CMD_MEM
   78:     {
   79:         UINT16  vAddrLoop = vAddr+vLoop;
002C01 E529              MOV      A,vAddr+01H
002C03 252D              ADD      A,vLoop+01H
002C05 F52F              MOV      vAddrLoop+01H,A
002C07 E528              MOV      A,vAddr
002C09 352C              ADDC     A,vLoop
002C0B F52E              MOV      vAddrLoop,A
   80: 
   81:         if ((vLoop%16) == 0)
002C0D E52D              MOV      A,vLoop+01H
002C0F 540F              ANL      A,#0FH
002C11 700E              JNZ      ?C0029?CMD_MEM
   82:         {
   83:             printf("\n\r %.4hX:", vAddrLoop);
002C13 7BFF              MOV      R3,#0FFH
002C15 7A19              MOV      R2,#HIGH 01001919H
002C17 7919              MOV      R1,#LOW 01001919H
002C19 852E33            MOV      ?_printf?BYTE+03H,vAddrLoop
002C1C 852F34            MOV      ?_printf?BYTE+04H,vAddrLoop+01H
   84:         }
002C1F 800C              SJMP     ?C0074?CMD_MEM
002C21         ?C0029?CMD_MEM:
   85:         else if ((vLoop%8) == 0)
002C21 E52D              MOV      A,vLoop+01H
002C23 5407              ANL      A,#07H
002C25 7009              JNZ      ?C0030?CMD_MEM
   86:         {
   87:             printf(" -");
002C27 7BFF              MOV      R3,#0FFH
002C29 7A19              MOV      R2,#HIGH 01001923H
002C2B 7923              MOV      R1,#LOW 01001923H
002C2D         
002C2D 120700            LCALL    _printf
   88:         }
002C30         ?C0030?CMD_MEM:
   89: 
   90:         printf(" %.2bX", (bCode ? CODE_U8(vAddrLoop) : XDATA_U8(vAddrLoop)));
002C30 F1B9              ACALL    ?L?COM0044
002C32 300807            JNB      bCode,?C0032?CMD_MEM
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 68


002C35 F1AB              ACALL    ?L?COM0034
002C37 E4                CLR      A
002C38 93                MOVC     A,@A+DPTR
002C39 FF                MOV      R7,A
002C3A 8004              SJMP     ?C0033?CMD_MEM
002C3C         ?C0032?CMD_MEM:
002C3C F1AB              ACALL    ?L?COM0034
002C3E E0                MOVX     A,@DPTR
002C3F FF                MOV      R7,A
002C40         ?C0033?CMD_MEM:
002C40 8F33              MOV      ?_printf?BYTE+03H,R7
002C42 120700            LCALL    _printf
   91:     }
002C45 052D              INC      vLoop+01H
002C47 E52D              MOV      A,vLoop+01H
002C49 7002              JNZ      ?C0070?CMD_MEM
002C4B 052C              INC      vLoop
002C4D         ?C0070?CMD_MEM:
002C4D 80A7              SJMP     ?C0026?CMD_MEM
   92: }
002C4F         ?C0003?CMD_MEM:
002C4F 22                RET      
----- FUNCTION CMD_Mem_Read (END) -------


----- FUNCTION CMD_Mem_Write (BEGIN) -----
 FILE: '..\cli\cmd\cmd_mem.c'
  109: void CMD_Mem_Write(void)
  110: {
  111:     BOOL    bCode;
  112:     UINT16  vAddr;
  113:     UINT8   vCount;
  114:     UINT8   vLoop;
  115: 
  116:     if (CLI_vParam < 4)
002C50 900014            MOV      DPTR,#vCmdParamCount
002C53 E0                MOVX     A,@DPTR
002C54 C3                CLR      C
002C55 9404              SUBB     A,#04H
002C57 5002              JNC      ?C0034?CMD_MEM
  117:     {
  118:         printf("\n\rInvalid Parameter!");
002C59 8048              SJMP     ?C0076?CMD_MEM
  119:         return;
  120:     }
002C5B         ?C0034?CMD_MEM:
  121: 
  122:     if (IsStrEqual(CLI_aParam[1], "code"))
002C5B F188              ACALL    ?L?COM0017
002C5D 7001              JNZ      ?C0039?CMD_MEM
002C5F D3                SETB     C
002C60         ?C0039?CMD_MEM:
002C60         ?C0040?CMD_MEM:
002C60 4012              JC       ?C0037?CMD_MEM
002C62 74FF              MOV      A,#0FFH
002C64 C3                CLR      C
002C65 7001              JNZ      ?C0041?CMD_MEM
002C67 D3                SETB     C
002C68         ?C0041?CMD_MEM:
002C68         ?C0042?CMD_MEM:
002C68 400A              JC       ?C0037?CMD_MEM
002C6A F19E              ACALL    ?L?COM000E
002C6C F193              ACALL    ?L?COM002B
002C6E 7002              JNZ      ?C0043?CMD_MEM
002C70 7F01              MOV      R7,#01H
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 69


002C72         ?C0043?CMD_MEM:
002C72         ?C0044?CMD_MEM:
002C72 8002              SJMP     ?C0038?CMD_MEM
002C74         ?C0037?CMD_MEM:
002C74 7F00              MOV      R7,#00H
002C76         ?C0038?CMD_MEM:
002C76 EF                MOV      A,R7
002C77 6004              JZ       ?C0036?CMD_MEM
  123:     {
  124:         bCode = TRUE;
002C79 D208              SETB     bCode
  125:     }
002C7B 802F              SJMP     ?C0045?CMD_MEM
002C7D         ?C0036?CMD_MEM:
  126:     else if (IsStrEqual(CLI_aParam[1], "xdata"))
002C7D F188              ACALL    ?L?COM0017
002C7F 7001              JNZ      ?C0049?CMD_MEM
002C81 D3                SETB     C
002C82         ?C0049?CMD_MEM:
002C82         ?C0050?CMD_MEM:
002C82 4016              JC       ?C0047?CMD_MEM
002C84 74FF              MOV      A,#0FFH
002C86 C3                CLR      C
002C87 7001              JNZ      ?C0051?CMD_MEM
002C89 D3                SETB     C
002C8A         ?C0051?CMD_MEM:
002C8A         ?C0052?CMD_MEM:
002C8A 400E              JC       ?C0047?CMD_MEM
002C8C F19E              ACALL    ?L?COM000E
002C8E 7A19              MOV      R2,#HIGH 01001913H
002C90 7913              MOV      R1,#LOW 01001913H
002C92 F197              ACALL    ?L?COM002C
002C94 7002              JNZ      ?C0053?CMD_MEM
002C96 7F01              MOV      R7,#01H
002C98         ?C0053?CMD_MEM:
002C98         ?C0054?CMD_MEM:
002C98 8002              SJMP     ?C0048?CMD_MEM
002C9A         ?C0047?CMD_MEM:
002C9A 7F00              MOV      R7,#00H
002C9C         ?C0048?CMD_MEM:
002C9C EF                MOV      A,R7
002C9D 6004              JZ       ?C0046?CMD_MEM
  127:     {
  128:         bCode = FALSE;
002C9F C208              CLR      bCode
  129:     }
002CA1 8009              SJMP     ?C0045?CMD_MEM
002CA3         ?C0046?CMD_MEM:
  130:     else
  131:     {
  132:         printf("\n\rInvalid Parameter!");
002CA3         
002CA3 7BFF              MOV      R3,#0FFH
002CA5 7A18              MOV      R2,#HIGH 010018F9H
002CA7 79F9              MOV      R1,#LOW 010018F9H
002CA9 020700            LJMP     _printf
  133:         return;
  134:     }
002CAC         ?C0045?CMD_MEM:
  135: 
  136:     vAddr  = (UINT16)strtoul(CLI_aParam[2], NULL, 0);
002CAC 900008            MOV      DPTR,#aCmdParam+04H
002CAF F146              ACALL    ?L?COM0002
002CB1 C003              PUSH     AR3
002CB3 F150              ACALL    ?L?COM0003
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 70


002CB5 D003              POP      AR3
002CB7 F1C0              ACALL    ?L?COM003F
  137:     vCount = CLI_vParam - 3;
002CB9 900014            MOV      DPTR,#vCmdParamCount
002CBC E0                MOVX     A,@DPTR
002CBD 24FD              ADD      A,#0FDH
002CBF F52A              MOV      vCount,A
  138: 
  139:     for (vLoop = 0; vLoop < vCount; vLoop++)
002CC1 E4                CLR      A
002CC2 F52B              MOV      vLoop,A
002CC4         ?C0056?CMD_MEM:
002CC4 E52B              MOV      A,vLoop
002CC6 C3                CLR      C
002CC7 952A              SUBB     A,vCount
002CC9 5073              JNC      ?C0035?CMD_MEM
  140:     {
  141:         UINT16  vAddrLoop = vAddr+vLoop;
002CCB AF2B              MOV      R7,vLoop
002CCD 7E00              MOV      R6,#00H
002CCF E529              MOV      A,vAddr+01H
002CD1 2F                ADD      A,R7
002CD2 F52D              MOV      vAddrLoop+01H,A
002CD4 EE                MOV      A,R6
002CD5 3528              ADDC     A,vAddr
002CD7 F52C              MOV      vAddrLoop,A
  142:         UINT8   vData = (UINT8)strtoul(CLI_aParam[3+vLoop], NULL, 0);
002CD9 EF                MOV      A,R7
002CDA 25E0              ADD      A,ACC
002CDC FF                MOV      R7,A
002CDD EE                MOV      A,R6
002CDE 33                RLC      A
002CDF FE                MOV      R6,A
002CE0 740A              MOV      A,#LOW aCmdParam+06H
002CE2 2F                ADD      A,R7
002CE3 F582              MOV      DPL,A
002CE5 7400              MOV      A,#HIGH aCmdParam+06H
002CE7 3E                ADDC     A,R6
002CE8 F583              MOV      DPH,A
002CEA F146              ACALL    ?L?COM0002
002CEC C003              PUSH     AR3
002CEE F150              ACALL    ?L?COM0003
002CF0 D003              POP      AR3
002CF2 120EBA            LCALL    _strtoul
002CF5 8F2E              MOV      vData,R7
  143: 
  144:         if ((vLoop%16) == 0)
002CF7 E52B              MOV      A,vLoop
002CF9 540F              ANL      A,#0FH
002CFB 700E              JNZ      ?C0059?CMD_MEM
  145:         {
  146:             printf("\n\r %.4hX:", vAddrLoop);
002CFD 7BFF              MOV      R3,#0FFH
002CFF 7A19              MOV      R2,#HIGH 01001919H
002D01 7919              MOV      R1,#LOW 01001919H
002D03 852C33            MOV      ?_printf?BYTE+03H,vAddrLoop
002D06 852D34            MOV      ?_printf?BYTE+04H,vAddrLoop+01H
  147:         }
002D09 800C              SJMP     ?C0077?CMD_MEM
002D0B         ?C0059?CMD_MEM:
  148:         else if ((vLoop%8) == 0)
002D0B E52B              MOV      A,vLoop
002D0D 5407              ANL      A,#07H
002D0F 7009              JNZ      ?C0060?CMD_MEM
  149:         {
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 71


  150:             printf(" -");
002D11 7BFF              MOV      R3,#0FFH
002D13 7A19              MOV      R2,#HIGH 01001923H
002D15 7923              MOV      R1,#LOW 01001923H
002D17         
002D17 120700            LCALL    _printf
  151:         }
002D1A         ?C0060?CMD_MEM:
  152: 
  153:         if (bCode)
002D1A 30080C            JNB      bCode,?C0062?CMD_MEM
  154:         {
  155:             EEPROM_MEMCPY(vAddrLoop, 1, &vData);
002D1D         ?C0064?CMD_MEM:
  156:             printf(" %.2bX", CODE_U8(vAddrLoop));
002D1D F1B9              ACALL    ?L?COM0044
002D1F 852D82            MOV      DPL,vAddrLoop+01H
002D22 852C83            MOV      DPH,vAddrLoop
002D25 E4                CLR      A
002D26 93                MOVC     A,@A+DPTR
  157:         }
002D27 800C              SJMP     ?C0075?CMD_MEM
002D29         ?C0062?CMD_MEM:
  158:         else
  159:         {
  160:             XDATA_U8(vAddrLoop) = vData;
002D29 852D82            MOV      DPL,vAddrLoop+01H
002D2C 852C83            MOV      DPH,vAddrLoop
002D2F E52E              MOV      A,vData
002D31 F0                MOVX     @DPTR,A
  161:             printf(" %.2bX", XDATA_U8(vAddrLoop));
002D32 F1B9              ACALL    ?L?COM0044
002D34 E0                MOVX     A,@DPTR
002D35         
002D35 F533              MOV      ?_printf?BYTE+03H,A
002D37 120700            LCALL    _printf
  162:         }
  163:     }
002D3A         ?C0058?CMD_MEM:
002D3A 052B              INC      vLoop
002D3C 8086              SJMP     ?C0056?CMD_MEM
  164: }
002D3E         ?C0035?CMD_MEM:
002D3E 22                RET      
----- FUNCTION CMD_Mem_Write (END) -------


----- FUNCTION CMD_System_Reboot (BEGIN) -----
 FILE: '..\cli\cmd\cmd_system.c'
  113: void CMD_System_Reboot(void)
  114: {
  115:     printf("\n\r System Rebooting ...");
  116: 
002D3F 7BFF              MOV      R3,#0FFH
002D41 7A15              MOV      R2,#HIGH 010015C2H
002D43 79C2              MOV      R1,#LOW 010015C2H
002D45 120700            LCALL    _printf
  117:     for (;;)
  118:     {
002D48         ?C0018?CMD_SYSTEM:
  119:         DRV_RESET_SoftwareReset();
002D48 75EF12            MOV      RSTSRC,#012H
  120:     }
002D4B 80FB              SJMP     ?C0018?CMD_SYSTEM
----- FUNCTION CMD_System_Reboot (END) -------
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 72




----- FUNCTION CMD_C2M_Reset (BEGIN) -----
 FILE: '..\cli\cmd\cmd_c2m.c'
   39: void CMD_C2M_Reset(void)
   40: {
   41:     printf("\n\rC2M Reset Target Device ... ");
   42:     printf(DRV_C2M_Reset()?"Done.":"Fail.");
002D4D 7BFF              MOV      R3,#0FFH
002D4F 7A10              MOV      R2,#HIGH 0100105EH
002D51 795E              MOV      R1,#LOW 0100105EH
002D53 120700            LCALL    _printf
   43: }
002D56 121FE8            LCALL    DRV_C2M_Reset
002D59 7BFF              MOV      R3,#0FFH
002D5B 5006              JNC      ?C0001?CMD_C2M
002D5D 7A10              MOV      R2,#HIGH 0100107DH
002D5F 797D              MOV      R1,#LOW 0100107DH
002D61 8004              SJMP     ?C0002?CMD_C2M
002D63         ?C0001?CMD_C2M:
002D63 7A10              MOV      R2,#HIGH 01001083H
002D65 7983              MOV      R1,#LOW 01001083H
002D67         ?C0002?CMD_C2M:
002D67 020700            LJMP     _printf
----- FUNCTION CMD_C2M_Reset (END) -------


----- FUNCTION CMD_C2M_Probe (BEGIN) -----
 FILE: '..\cli\cmd\cmd_c2m.c'
   60: void CMD_C2M_Probe(void)
   61: {
   62:     printf("\n\rC2M Probe Target Device ID ... ");
   63:     printf("%.8lX", DRV_C2M_Probe());
002D6A 7BFF              MOV      R3,#0FFH
002D6C 7A10              MOV      R2,#HIGH 01001089H
002D6E 7989              MOV      R1,#LOW 01001089H
002D70 120700            LCALL    _printf
   64: }
002D73 121D00            LCALL    DRV_C2M_Probe
002D76 8F36              MOV      ?_printf?BYTE+06H,R7
002D78 8E35              MOV      ?_printf?BYTE+05H,R6
002D7A 8D34              MOV      ?_printf?BYTE+04H,R5
002D7C 8C33              MOV      ?_printf?BYTE+03H,R4
002D7E 7BFF              MOV      R3,#0FFH
002D80 7A10              MOV      R2,#HIGH 010010ABH
002D82 79AB              MOV      R1,#LOW 010010ABH
002D84 020700            LJMP     _printf
----- FUNCTION CMD_C2M_Probe (END) -------


----- FUNCTION CMD_C2M_ChipErase (BEGIN) -----
 FILE: '..\cli\cmd\cmd_c2m.c'
   81: void CMD_C2M_ChipErase(void)
   82: {
   83:     printf("\n\rC2M Target Device Chip Erase ... ");
   84:     printf(DRV_C2M_ChipErase()?"Done.":"Fail.");
002D87 7BFF              MOV      R3,#0FFH
002D89 7A10              MOV      R2,#HIGH 010010B1H
002D8B 79B1              MOV      R1,#LOW 010010B1H
002D8D 120700            LCALL    _printf
   85: }
002D90 121F5F            LCALL    DRV_C2M_ChipErase
002D93 7BFF              MOV      R3,#0FFH
002D95 5006              JNC      ?C0005?CMD_C2M
002D97 7A10              MOV      R2,#HIGH 0100107DH
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 73


002D99 797D              MOV      R1,#LOW 0100107DH
002D9B 8004              SJMP     ?C0006?CMD_C2M
002D9D         ?C0005?CMD_C2M:
002D9D 7A10              MOV      R2,#HIGH 01001083H
002D9F 7983              MOV      R1,#LOW 01001083H
002DA1         ?C0006?CMD_C2M:
002DA1 020700            LJMP     _printf
----- FUNCTION CMD_C2M_ChipErase (END) -------


----- FUNCTION CMD_C2M_PageErase (BEGIN) -----
 FILE: '..\cli\cmd\cmd_c2m.c'
  102: void CMD_C2M_PageErase(void)
  103: {
  104:     UINT8   vPageNo;
  105: 
  106:     if (CLI_vParam != 2)
002DA4 900014            MOV      DPTR,#vCmdParamCount
002DA7 E0                MOVX     A,@DPTR
002DA8 6402              XRL      A,#02H
002DAA 6004              JZ       ?C0008?CMD_C2M
  107:     {
  108:         printf("\n\rInvalid Parameter!");
002DAC F1B2              ACALL    ?L?COM0043
002DAE 802F              SJMP     ?C0039?CMD_C2M
  109:         return;
  110:     }
002DB0         ?C0008?CMD_C2M:
  111: 
  112:     vPageNo = (UINT8)strtoul(CLI_aParam[1], NULL, 0);
002DB0 900006            MOV      DPTR,#aCmdParam+02H
002DB3 F146              ACALL    ?L?COM0002
002DB5 C003              PUSH     AR3
002DB7 F150              ACALL    ?L?COM0003
002DB9 D003              POP      AR3
002DBB 120EBA            LCALL    _strtoul
002DBE 8F28              MOV      vPageNo,R7
  113: 
  114:     printf("\n\rC2 Master Page Erase: page_no=0x%.2bX ... ", vPageNo);
002DC0 7BFF              MOV      R3,#0FFH
002DC2 7A10              MOV      R2,#HIGH 010010EAH
002DC4 79EA              MOV      R1,#LOW 010010EAH
002DC6 852833            MOV      ?_printf?BYTE+03H,vPageNo
002DC9 120700            LCALL    _printf
  115:     if (DRV_C2M_PageErase(vPageNo))
002DCC AF28              MOV      R7,vPageNo
002DCE 121E63            LCALL    _DRV_C2M_PageErase
002DD1 7BFF              MOV      R3,#0FFH
002DD3 5006              JNC      ?C0010?CMD_C2M
  116:     {
  117:         printf("Done.");
002DD5 7A10              MOV      R2,#HIGH 0100107DH
002DD7 797D              MOV      R1,#LOW 0100107DH
002DD9         
  118:     }
002DD9 8004              SJMP     ?C0039?CMD_C2M
002DDB         ?C0010?CMD_C2M:
  119:     else
  120:     {
  121:         printf("Fail.");
002DDB 7A10              MOV      R2,#HIGH 01001083H
002DDD 7983              MOV      R1,#LOW 01001083H
002DDF         
002DDF 020700            LJMP     _printf
  122:     }
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 74


----- FUNCTION CMD_C2M_PageErase (END) -------


----- FUNCTION CMD_C2M_ReadFlash (BEGIN) -----
 FILE: '..\cli\cmd\cmd_c2m.c'
  140: void CMD_C2M_ReadFlash(void)
  141: {
  142:     UINT16          vAddr;
  143:     UINT8           vReadLen;
  144:     UINT8 SEG_XDATA aReadBuf[128];
  145: 
  146:     memset(aReadBuf, 0, sizeof(aReadBuf));
002DE2 7E00              MOV      R6,#00H
002DE4 7F80              MOV      R7,#080H
002DE6 F1E0              ACALL    ?L?COM0031
002DE8 B40205            CJNE     A,#02H,?C0012?CMD_C2M
  147: 
  148:     if (CLI_vParam == 2)
  149:     {
  150:         vReadLen = 1;
002DEB 752A01            MOV      vReadLen,#01H
  151:     }
002DEE 8018              SJMP     ?C0013?CMD_C2M
002DF0         ?C0012?CMD_C2M:
  152:     else if (CLI_vParam == 3)
002DF0 EF                MOV      A,R7
002DF1 B40312            CJNE     A,#03H,?C0014?CMD_C2M
  153:     {
  154:         vReadLen = (UINT8)strtoul(CLI_aParam[2], NULL, 0);
002DF4 900008            MOV      DPTR,#aCmdParam+04H
002DF7 F146              ACALL    ?L?COM0002
002DF9 C003              PUSH     AR3
002DFB F150              ACALL    ?L?COM0003
002DFD D003              POP      AR3
002DFF 120EBA            LCALL    _strtoul
002E02 8F2A              MOV      vReadLen,R7
  155:     }
002E04 8002              SJMP     ?C0013?CMD_C2M
002E06         ?C0014?CMD_C2M:
  156:     else
  157:     {
  158:         printf("\n\rInvalid Parameter!");
002E06 8014              SJMP     ?C0040?CMD_C2M
  159:         return;
  160:     }
002E08         ?C0013?CMD_C2M:
  161: 
  162:     vAddr = (UINT16)strtoul(CLI_aParam[1], NULL, 0);
002E08 900006            MOV      DPTR,#aCmdParam+02H
002E0B F146              ACALL    ?L?COM0002
002E0D C003              PUSH     AR3
002E0F F150              ACALL    ?L?COM0003
002E11 D003              POP      AR3
002E13 F1C0              ACALL    ?L?COM003F
  163:     if (vReadLen > sizeof(aReadBuf))
002E15 E52A              MOV      A,vReadLen
002E17 D3                SETB     C
002E18 9480              SUBB     A,#080H
002E1A 4004              JC       ?C0017?CMD_C2M
  164:     {
  165:         printf("\n\rInvalid Parameter!");
002E1C         
002E1C F1B2              ACALL    ?L?COM0043
002E1E 8075              SJMP     ?C0041?CMD_C2M
  166:         return;
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 75


  167:     }
002E20         ?C0017?CMD_C2M:
  168: 
  169:     printf("\n\rC2 Master Read Flash: addr=0x%.4hX, len=0x%.2bX ... ",
002E20 7BFF              MOV      R3,#0FFH
002E22 7A11              MOV      R2,#HIGH 01001117H
002E24 7917              MOV      R1,#LOW 01001117H
002E26 F15D              ACALL    ?L?COM003C
002E28 852A35            MOV      ?_printf?BYTE+05H,vReadLen
002E2B 120700            LCALL    _printf
  170:            vAddr, vReadLen);
  171:     if (DRV_C2M_FlashRead(aReadBuf, vAddr, vReadLen))
002E2E 7E01              MOV      R6,#HIGH aReadBuf
002E30 7FAD              MOV      R7,#LOW aReadBuf
002E32 AB2A              MOV      R3,vReadLen
002E34 AD29              MOV      R5,vAddr+01H
002E36 AC28              MOV      R4,vAddr
002E38 1220BD            LCALL    _DRV_C2M_FlashRead
002E3B 5052              JNC      ?C0018?CMD_C2M
  172:     {
  173:         UINT8   vLoop;
  174: 
  175:         printf("Done.");
002E3D 7BFF              MOV      R3,#0FFH
002E3F 7A10              MOV      R2,#HIGH 0100107DH
002E41 797D              MOV      R1,#LOW 0100107DH
002E43 120700            LCALL    _printf
  176: 
  177:         for (vLoop = 0; vLoop < vReadLen; vLoop++)
002E46 E4                CLR      A
002E47 F52B              MOV      vLoop,A
002E49         ?C0019?CMD_C2M:
002E49 E52B              MOV      A,vLoop
002E4B C3                CLR      C
002E4C 952A              SUBB     A,vReadLen
002E4E 5048              JNC      ?C0016?CMD_C2M
  178:         {
  179:             if ((vLoop%16) == 0)
002E50 E52B              MOV      A,vLoop
002E52 540F              ANL      A,#0FH
002E54 7014              JNZ      ?C0022?CMD_C2M
  180:             {
  181:                 printf("\n\r %.4hX:", vAddr+vLoop);
002E56 7BFF              MOV      R3,#0FFH
002E58 7A11              MOV      R2,#HIGH 0100114EH
002E5A 794E              MOV      R1,#LOW 0100114EH
002E5C FE                MOV      R6,A
002E5D E529              MOV      A,vAddr+01H
002E5F 252B              ADD      A,vLoop
002E61 F534              MOV      ?_printf?BYTE+04H,A
002E63 EE                MOV      A,R6
002E64 3528              ADDC     A,vAddr
002E66 F533              MOV      ?_printf?BYTE+03H,A
  182:             }
002E68 800C              SJMP     ?C0042?CMD_C2M
002E6A         ?C0022?CMD_C2M:
  183:             else if ((vLoop%8) == 0)
002E6A E52B              MOV      A,vLoop
002E6C 5407              ANL      A,#07H
002E6E 7009              JNZ      ?C0023?CMD_C2M
  184:             {
  185:                 printf(" -");
002E70 7BFF              MOV      R3,#0FFH
002E72 7A11              MOV      R2,#HIGH 01001158H
002E74 7958              MOV      R1,#LOW 01001158H
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 76


002E76         
002E76 120700            LCALL    _printf
  186:             }
002E79         ?C0023?CMD_C2M:
  187: 
  188:             printf(" %.2bX", aReadBuf[vLoop]);
002E79 7BFF              MOV      R3,#0FFH
002E7B 7A11              MOV      R2,#HIGH 0100115BH
002E7D 795B              MOV      R1,#LOW 0100115BH
002E7F 74AD              MOV      A,#LOW aReadBuf
002E81 252B              ADD      A,vLoop
002E83 F1CC              ACALL    ?L?COM0033
002E85 E0                MOVX     A,@DPTR
002E86 F533              MOV      ?_printf?BYTE+03H,A
002E88 120700            LCALL    _printf
  189:         }
002E8B 052B              INC      vLoop
002E8D 80BA              SJMP     ?C0019?CMD_C2M
  190:     }
002E8F         ?C0018?CMD_C2M:
  191:     else
  192:     {
  193:         printf("Fail.");
002E8F 7BFF              MOV      R3,#0FFH
002E91 7A10              MOV      R2,#HIGH 01001083H
002E93 7983              MOV      R1,#LOW 01001083H
002E95         
002E95 120700            LCALL    _printf
  194:     }
  195: }
002E98         ?C0016?CMD_C2M:
002E98 22                RET      
----- FUNCTION CMD_C2M_ReadFlash (END) -------


----- FUNCTION CMD_C2M_WriteFlash (BEGIN) -----
 FILE: '..\cli\cmd\cmd_c2m.c'
  212: void CMD_C2M_WriteFlash(void)
  213: {
  214:     UINT8           vAddr;
  215:     UINT8           vDataLen;
  216:     UINT8 SEG_XDATA aWriteBuf[CLI_CMD_MAX_PARAM];
  217:     UINT8           vLoop;
  218: 
  219:     memset(aWriteBuf, 0, sizeof(aWriteBuf));
002E99 7E00              MOV      R6,#00H
002E9B 7F08              MOV      R7,#08H
002E9D F1E0              ACALL    ?L?COM0031
002E9F C3                CLR      C
002EA0 9403              SUBB     A,#03H
002EA2 401C              JC       ?C0043?CMD_C2M
  220: 
  221:     if (CLI_vParam >= 3)
  222:     {
  223:         vDataLen = CLI_vParam - 2;
002EA4 EF                MOV      A,R7
002EA5 24FE              ADD      A,#0FEH
002EA7 F529              MOV      vDataLen,A
  224:     }
  225:     else
  226:     {
  227:         printf("\n\rInvalid Parameter!");
  228:         return;
  229:     }
002EA9         ?C0027?CMD_C2M:
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 77


  230: 
  231:     vAddr = (UINT8)strtoul(CLI_aParam[1], NULL, 0);
002EA9 900006            MOV      DPTR,#aCmdParam+02H
002EAC F146              ACALL    ?L?COM0002
002EAE C003              PUSH     AR3
002EB0 F150              ACALL    ?L?COM0003
002EB2 D003              POP      AR3
002EB4 120EBA            LCALL    _strtoul
002EB7 8F28              MOV      vAddr,R7
  232:     if (vDataLen > sizeof(aWriteBuf))
002EB9 E529              MOV      A,vDataLen
002EBB D3                SETB     C
002EBC 9408              SUBB     A,#08H
002EBE 4005              JC       ?C0029?CMD_C2M
  233:     {
  234:         printf("\n\rInvalid Parameter!");
002EC0         
002EC0 F1B2              ACALL    ?L?COM0043
002EC2 020700            LJMP     _printf
  235:         return;
  236:     }
002EC5         ?C0029?CMD_C2M:
  237: 
  238:     for (vLoop = 0; vLoop < vDataLen; vLoop++)
002EC5 E4                CLR      A
002EC6 F52A              MOV      vLoop,A
002EC8         ?C0030?CMD_C2M:
002EC8 E52A              MOV      A,vLoop
002ECA C3                CLR      C
002ECB 9529              SUBB     A,vDataLen
002ECD 5025              JNC      ?C0031?CMD_C2M
  239:     {
  240:         aWriteBuf[vLoop] = (UINT8)strtoul(CLI_aParam[2+vLoop], NULL, 0);
002ECF E52A              MOV      A,vLoop
002ED1 25E0              ADD      A,ACC
002ED3 FF                MOV      R7,A
002ED4 E4                CLR      A
002ED5 33                RLC      A
002ED6 FE                MOV      R6,A
002ED7 7408              MOV      A,#LOW aCmdParam+04H
002ED9 2F                ADD      A,R7
002EDA F582              MOV      DPL,A
002EDC 7400              MOV      A,#HIGH aCmdParam+04H
002EDE 3E                ADDC     A,R6
002EDF F583              MOV      DPH,A
002EE1 F146              ACALL    ?L?COM0002
002EE3 C003              PUSH     AR3
002EE5 F150              ACALL    ?L?COM0003
002EE7 D003              POP      AR3
002EE9 120EBA            LCALL    _strtoul
002EEC F1C8              ACALL    ?L?COM0032
002EEE EF                MOV      A,R7
002EEF F0                MOVX     @DPTR,A
  241:     }
002EF0 052A              INC      vLoop
002EF2 80D4              SJMP     ?C0030?CMD_C2M
002EF4         ?C0031?CMD_C2M:
  242: 
  243:     printf("\n\rC2 Master Write Flash: addr=0X%.4hX, len=0x%.2bX ... ",
002EF4 7BFF              MOV      R3,#0FFH
002EF6 7A11              MOV      R2,#HIGH 01001162H
002EF8 7962              MOV      R1,#LOW 01001162H
002EFA F15D              ACALL    ?L?COM003C
002EFC 120700            LCALL    _printf
  244:            vAddr, vDataLen);
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 78


  245:     if (DRV_C2M_FlashWrite(vAddr, aWriteBuf, vDataLen))
002EFF AF28              MOV      R7,vAddr
002F01 7E00              MOV      R6,#00H
002F03 7C01              MOV      R4,#HIGH aWriteBuf
002F05 7DAD              MOV      R5,#LOW aWriteBuf
002F07 AB29              MOV      R3,vDataLen
002F09 121DC2            LCALL    _DRV_C2M_FlashWrite
002F0C 7BFF              MOV      R3,#0FFH
002F0E 5006              JNC      ?C0033?CMD_C2M
  246:     {
  247:         printf("Done.");
002F10 7A10              MOV      R2,#HIGH 0100107DH
002F12 797D              MOV      R1,#LOW 0100107DH
  248:     }
002F14 8004              SJMP     ?C0044?CMD_C2M
002F16         ?C0033?CMD_C2M:
  249:     else
  250:     {
  251:         printf("Fail.");
002F16 7A10              MOV      R2,#HIGH 01001083H
002F18 7983              MOV      R1,#LOW 01001083H
002F1A         
002F1A 120700            LCALL    _printf
  252:     }
002F1D         ?C0034?CMD_C2M:
  253: 
  254:     printf("\n\rData:");
002F1D 7BFF              MOV      R3,#0FFH
002F1F 7A11              MOV      R2,#HIGH 0100119AH
002F21 799A              MOV      R1,#LOW 0100119AH
002F23 120700            LCALL    _printf
  255:     for (vLoop = 0; vLoop < vDataLen; vLoop++)
002F26 E4                CLR      A
002F27 F52A              MOV      vLoop,A
002F29         ?C0035?CMD_C2M:
002F29 E52A              MOV      A,vLoop
002F2B C3                CLR      C
002F2C 9529              SUBB     A,vDataLen
002F2E 5012              JNC      ?C0028?CMD_C2M
  256:     {
  257:         printf(" %.2bX", aWriteBuf[vLoop]);
002F30 7BFF              MOV      R3,#0FFH
002F32 7A11              MOV      R2,#HIGH 0100115BH
002F34 795B              MOV      R1,#LOW 0100115BH
002F36 F1C8              ACALL    ?L?COM0032
002F38 E0                MOVX     A,@DPTR
002F39 F533              MOV      ?_printf?BYTE+03H,A
002F3B 120700            LCALL    _printf
  258:     }
002F3E 052A              INC      vLoop
002F40 80E7              SJMP     ?C0035?CMD_C2M
  259: }
002F42         ?C0028?CMD_C2M:
002F42 22                RET      
----- FUNCTION CMD_C2M_WriteFlash (END) -------


----- FUNCTION ?L?COM0001 (BEGIN) -----
002F43 900004            MOV      DPTR,#aCmdParam
002F46         ?L?COM0002:
002F46 E0                MOVX     A,@DPTR
002F47 FE                MOV      R6,A
002F48 A3                INC      DPTR
002F49 E0                MOVX     A,@DPTR
002F4A AA06              MOV      R2,AR6
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 79


002F4C F9                MOV      R1,A
002F4D 7B01              MOV      R3,#01H
002F4F 22                RET      
----- FUNCTION ?L?COM0001 (END) -------


----- FUNCTION ?L?COM0003 (BEGIN) -----
002F50 1B                DEC      R3
002F51 8B33              MOV      ?_strtoul?BYTE+03H,R3
002F53 753400            MOV      ?_strtoul?BYTE+04H,#00H
002F56 753500            MOV      ?_strtoul?BYTE+05H,#00H
002F59 E4                CLR      A
002F5A F536              MOV      ?_strtoul?BYTE+06H,A
002F5C 22                RET      
----- FUNCTION ?L?COM0003 (END) -------


----- FUNCTION ?L?COM003C (BEGIN) -----
002F5D 852833            MOV      ?_printf?BYTE+03H,vAddr
002F60 852934            MOV      ?_printf?BYTE+04H,vDataLen
002F63 22                RET      
----- FUNCTION ?L?COM003C (END) -------


----- FUNCTION ?L?COM0035 (BEGIN) -----
002F64 7401              MOV      A,#01H
002F66 7E00              MOV      R6,#00H
002F68 A829              MOV      R0,vBit
002F6A 08                INC      R0
002F6B 22                RET      
----- FUNCTION ?L?COM0035 (END) -------


----- FUNCTION ?L?COM0029 (BEGIN) -----
002F6C AF2A              MOV      R7,vValue
002F6E A929              MOV      R1,vBit
002F70 A801              MOV      R0,AR1
002F72 02027F            LJMP     ?C?LSHL
----- FUNCTION ?L?COM0029 (END) -------


----- FUNCTION ?L?COM002E (BEGIN) -----
002F75 E4                CLR      A
002F76 FE                MOV      R6,A
002F77 EF                MOV      A,R7
002F78 5D                ANL      A,R5
002F79 FF                MOV      R7,A
002F7A E4                CLR      A
002F7B FC                MOV      R4,A
002F7C FD                MOV      R5,A
002F7D 22                RET      
----- FUNCTION ?L?COM002E (END) -------


----- FUNCTION ?L?COM0028 (BEGIN) -----
002F7E EF                MOV      A,R7
002F7F 4B                ORL      A,R3
002F80 FF                MOV      R7,A
002F81 EE                MOV      A,R6
002F82 4A                ORL      A,R2
002F83 ED                MOV      A,R5
002F84 49                ORL      A,R1
002F85 EC                MOV      A,R4
002F86 48                ORL      A,R0
002F87 22                RET      
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 80


----- FUNCTION ?L?COM0028 (END) -------


----- FUNCTION ?L?COM0017 (BEGIN) -----
002F88 900006            MOV      DPTR,#aCmdParam+02H
002F8B         ?L?COM0018:
002F8B E0                MOVX     A,@DPTR
002F8C FE                MOV      R6,A
002F8D A3                INC      DPTR
002F8E E0                MOVX     A,@DPTR
002F8F FF                MOV      R7,A
002F90 4E                ORL      A,R6
002F91 C3                CLR      C
002F92 22                RET      
----- FUNCTION ?L?COM0017 (END) -------


----- FUNCTION ?L?COM002B (BEGIN) -----
002F93 7A19              MOV      R2,#HIGH 0100190EH
002F95 790E              MOV      R1,#LOW 0100190EH
002F97         ?L?COM002C:
002F97 120495            LCALL    ?C?STRCMP
002F9A EF                MOV      A,R7
002F9B 7F00              MOV      R7,#00H
002F9D 22                RET      
----- FUNCTION ?L?COM002B (END) -------


----- FUNCTION ?L?COM000E (BEGIN) -----
002F9E AA06              MOV      R2,AR6
002FA0 A907              MOV      R1,AR7
002FA2 A801              MOV      R0,AR1
002FA4         ?L?COM000F:
002FA4 AC02              MOV      R4,AR2
002FA6 7D01              MOV      R5,#01H
002FA8 7BFF              MOV      R3,#0FFH
002FAA 22                RET      
----- FUNCTION ?L?COM000E (END) -------


----- FUNCTION ?L?COM0034 (BEGIN) -----
002FAB 852F82            MOV      DPL,vAddrLoop+01H
002FAE 852E83            MOV      DPH,vAddrLoop
002FB1 22                RET      
----- FUNCTION ?L?COM0034 (END) -------


----- FUNCTION ?L?COM0043 (BEGIN) -----
002FB2 7BFF              MOV      R3,#0FFH
002FB4 7A10              MOV      R2,#HIGH 010010D5H
002FB6 79D5              MOV      R1,#LOW 010010D5H
002FB8 22                RET      
----- FUNCTION ?L?COM0043 (END) -------


----- FUNCTION ?L?COM0044 (BEGIN) -----
002FB9 7BFF              MOV      R3,#0FFH
002FBB 7A19              MOV      R2,#HIGH 01001926H
002FBD 7926              MOV      R1,#LOW 01001926H
002FBF 22                RET      
----- FUNCTION ?L?COM0044 (END) -------


----- FUNCTION ?L?COM003F (BEGIN) -----
002FC0 120EBA            LCALL    _strtoul
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 81


002FC3 8E28              MOV      vAddr,R6
002FC5 8F29              MOV      vAddr+01H,R7
002FC7 22                RET      
----- FUNCTION ?L?COM003F (END) -------


----- FUNCTION ?L?COM0032 (BEGIN) -----
002FC8 74AD              MOV      A,#LOW aWriteBuf
002FCA 252A              ADD      A,vLoop
002FCC         ?L?COM0033:
002FCC F582              MOV      DPL,A
002FCE E4                CLR      A
002FCF 3401              ADDC     A,#HIGH aWriteBuf
002FD1 F583              MOV      DPH,A
002FD3 22                RET      
----- FUNCTION ?L?COM0032 (END) -------


----- FUNCTION ?L?COM0040 (BEGIN) -----
002FD4 7BFF              MOV      R3,#0FFH
002FD6 7A0B              MOV      R2,#HIGH 01000BABH
002FD8 79AB              MOV      R1,#LOW 01000BABH
002FDA 120700            LCALL    _printf
002FDD 7BFF              MOV      R3,#0FFH
002FDF 22                RET      
----- FUNCTION ?L?COM0040 (END) -------


----- FUNCTION ?L?COM0031 (BEGIN) -----
002FE0 7D00              MOV      R5,#00H
002FE2 7B01              MOV      R3,#01H
002FE4 7A01              MOV      R2,#HIGH aWriteBuf
002FE6 79AD              MOV      R1,#LOW aWriteBuf
002FE8 12059B            LCALL    ?C?MEMSET
002FEB 900014            MOV      DPTR,#vCmdParamCount
002FEE E0                MOVX     A,@DPTR
002FEF FF                MOV      R7,A
002FF0 22                RET      
----- FUNCTION ?L?COM0031 (END) -------


----- FUNCTION ?L?COM0030 (BEGIN) -----
002FF1 D297              SETB     IO_C2M_SCL
002FF3 A215              MOV      C,bIns1
002FF5 92A0              MOV      IO_C2M_SDA,C
002FF7 C297              CLR      IO_C2M_SCL
002FF9 22                RET      
----- FUNCTION ?L?COM0030 (END) -------


----- FUNCTION ?L?COM0004 (BEGIN) -----
002FFA 7831              MOV      R0,#LOW _timeout
002FFC         ?L?COM0005:
002FFC 74FF              MOV      A,#0FFH
002FFE 120294            LCALL    ?C?LLDIIDATA8
003001 EC                MOV      A,R4
003002 4D                ORL      A,R5
003003 4E                ORL      A,R6
003004 4F                ORL      A,R7
003005 22                RET      
----- FUNCTION ?L?COM0004 (END) -------


----- FUNCTION ?L?COM0008 (BEGIN) -----
003006 7B01              MOV      R3,#01H
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 82


003008 7A01              MOV      R2,#HIGH aCmdBuf
00300A 795B              MOV      R1,#LOW aCmdBuf
00300C 12002E            LCALL    _strlen
00300F 9001AC            MOV      DPTR,#vCmdBufCount
003012 22                RET      
----- FUNCTION ?L?COM0008 (END) -------


----- FUNCTION ?L?COM0009 (BEGIN) -----
003013 E0                MOVX     A,@DPTR
003014 FC                MOV      R4,A
003015 A3                INC      DPTR
003016 E0                MOVX     A,@DPTR
003017 FD                MOV      R5,A
003018 A3                INC      DPTR
003019 E0                MOVX     A,@DPTR
00301A FE                MOV      R6,A
00301B A3                INC      DPTR
00301C E0                MOVX     A,@DPTR
00301D FF                MOV      R7,A
00301E         ?L?COM000A:
00301E AB0B              MOV      R3,vTickCount+03H
003020 AA0A              MOV      R2,vTickCount+02H
003022 A909              MOV      R1,vTickCount+01H
003024 A808              MOV      R0,vTickCount
003026 C3                CLR      C
003027 02026E            LJMP     ?C?ULCMP
----- FUNCTION ?L?COM0009 (END) -------


----- FUNCTION ?L?COM000B (BEGIN) -----
00302A 12002E            LCALL    _strlen
00302D         ?L?COM000C:
00302D E525              MOV      A,vLoop
00302F         ?L?COM000D:
00302F 25E0              ADD      A,ACC
003031 25E0              ADD      A,ACC
003033 2473              ADD      A,#LOW aCmdTable+02H
003035 F582              MOV      DPL,A
003037 E4                CLR      A
003038 340C              ADDC     A,#HIGH aCmdTable+02H
00303A F583              MOV      DPH,A
00303C E4                CLR      A
00303D 93                MOVC     A,@A+DPTR
00303E 22                RET      
----- FUNCTION ?L?COM000B (END) -------


----- FUNCTION ?L?COM0010 (BEGIN) -----
00303F 7F01              MOV      R7,#01H
003041 12245C            LCALL    _VT_MoveRight
003044         ?L?COM0011:
003044 9001AC            MOV      DPTR,#vCmdBufCount
003047 E0                MOVX     A,@DPTR
003048 04                INC      A
003049 F0                MOVX     @DPTR,A
00304A 22                RET      
----- FUNCTION ?L?COM0010 (END) -------


----- FUNCTION ?L?COM0012 (BEGIN) -----
00304B 7BFF              MOV      R3,#0FFH
00304D 7A0B              MOV      R2,#HIGH 01000B3EH
00304F 793E              MOV      R1,#LOW 01000B3EH
003051 120700            LCALL    _printf
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 83


003054         ?L?COM0013:
003054 9001AC            MOV      DPTR,#vCmdBufCount
003057 E0                MOVX     A,@DPTR
003058 14                DEC      A
003059 F0                MOVX     @DPTR,A
00305A 22                RET      
----- FUNCTION ?L?COM0012 (END) -------


----- FUNCTION ?L?COM0014 (BEGIN) -----
00305B 9209              MOV      bIntState,C
00305D 53A6FE            ANL      P2MDOUT,#0FEH
003060 43A580            ORL      P1MDOUT,#080H
003063 A212              MOV      C,bHigh
003065 92A0              MOV      IO_C2M_SDA,C
003067 22                RET      
----- FUNCTION ?L?COM0014 (END) -------


----- FUNCTION ?L?COM0015 (BEGIN) -----
003068 E525              MOV      A,vLoop
00306A 25E0              ADD      A,ACC
00306C 25E0              ADD      A,ACC
00306E 2471              ADD      A,#LOW aCmdTable
003070 F582              MOV      DPL,A
003072 E4                CLR      A
003073 340C              ADDC     A,#HIGH aCmdTable
003075 F583              MOV      DPH,A
003077 E4                CLR      A
003078 93                MOVC     A,@A+DPTR
003079         ?L?COM0016:
003079 FE                MOV      R6,A
00307A 7401              MOV      A,#01H
00307C 93                MOVC     A,@A+DPTR
00307D AA06              MOV      R2,AR6
00307F 22                RET      
----- FUNCTION ?L?COM0015 (END) -------


----- FUNCTION ?L?COM0019 (BEGIN) -----
003080 8E2C              MOV      pStr,R6
003082 8F2D              MOV      pStr+01H,R7
003084         ?L?COM001A:
003084 AA06              MOV      R2,AR6
003086 A907              MOV      R1,AR7
003088 7B01              MOV      R3,#01H
00308A         ?L?COM001B:
00308A 12002E            LCALL    _strlen
00308D EF                MOV      A,R7
00308E 4E                ORL      A,R6
00308F C3                CLR      C
003090 22                RET      
----- FUNCTION ?L?COM0019 (END) -------


----- FUNCTION ?L?COM001C (BEGIN) -----
003091 A2A0              MOV      C,IO_C2M_SDA
003093 D297              SETB     IO_C2M_SCL
003095 9207              MOV      bC2Bit7,C
003097         ?L?COM001D:
003097 53A6FE            ANL      P2MDOUT,#0FEH
00309A         ?L?COM001E:
00309A 53A57F            ANL      P1MDOUT,#07FH
00309D A209              MOV      C,bIntState
00309F 92AF              MOV      EA,C
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 84


0030A1 22                RET      
----- FUNCTION ?L?COM001C (END) -------


----- FUNCTION ?L?COM001F (BEGIN) -----
0030A2 D297              SETB     IO_C2M_SCL
0030A4 43A601            ORL      P2MDOUT,#01H
0030A7 A214              MOV      C,bIns0
0030A9 92A0              MOV      IO_C2M_SDA,C
0030AB C297              CLR      IO_C2M_SCL
0030AD 22                RET      
----- FUNCTION ?L?COM001F (END) -------


----- FUNCTION ?L?COM0020 (BEGIN) -----
0030AE E0                MOVX     A,@DPTR
0030AF 5403              ANL      A,#03H
0030B1 F0                MOVX     @DPTR,A
0030B2 E0                MOVX     A,@DPTR
0030B3         ?L?COM0021:
0030B3 75F051            MOV      B,#051H
0030B6 A4                MUL      AB
0030B7 2417              ADD      A,#LOW aHistoryBuf
0030B9 F9                MOV      R1,A
0030BA 7400              MOV      A,#HIGH aHistoryBuf
0030BC 35F0              ADDC     A,B
0030BE 22                RET      
----- FUNCTION ?L?COM0020 (END) -------


----- FUNCTION ?L?COM0022 (BEGIN) -----
0030BF 43A580            ORL      P1MDOUT,#080H
0030C2 C297              CLR      IO_C2M_SCL
0030C4 7F14              MOV      R7,#014H
0030C6 7E00              MOV      R6,#00H
0030C8 121CE0            LCALL    _DRV_CPU_DelayUs
0030CB D297              SETB     IO_C2M_SCL
0030CD 7F02              MOV      R7,#02H
0030CF 7E00              MOV      R6,#00H
0030D1 121CE0            LCALL    _DRV_CPU_DelayUs
0030D4 53A57F            ANL      P1MDOUT,#07FH
0030D7 22                RET      
----- FUNCTION ?L?COM0022 (END) -------


----- FUNCTION ?L?COM0024 (BEGIN) -----
0030D8 FF                MOV      R7,A
0030D9 E4                CLR      A
0030DA 350A              ADDC     A,vTickCount+02H
0030DC FE                MOV      R6,A
0030DD E4                CLR      A
0030DE 3509              ADDC     A,vTickCount+01H
0030E0 FD                MOV      R5,A
0030E1 E4                CLR      A
0030E2 3508              ADDC     A,vTickCount
0030E4 FC                MOV      R4,A
0030E5 22                RET      
----- FUNCTION ?L?COM0024 (END) -------


----- FUNCTION ?L?COM0025 (BEGIN) -----
0030E6 122597            LCALL    VT_SaveCursorPosition
0030E9 9001AC            MOV      DPTR,#vCmdBufCount
0030EC E0                MOVX     A,@DPTR
0030ED 245B              ADD      A,#LOW aCmdBuf
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 85


0030EF F9                MOV      R1,A
0030F0 E4                CLR      A
0030F1 3401              ADDC     A,#HIGH aCmdBuf
0030F3 753301            MOV      ?_printf?BYTE+03H,#01H
0030F6 F534              MOV      ?_printf?BYTE+04H,A
0030F8 8935              MOV      ?_printf?BYTE+05H,R1
0030FA 7BFF              MOV      R3,#0FFH
0030FC 22                RET      
----- FUNCTION ?L?COM0025 (END) -------


----- FUNCTION ?L?COM0026 (BEGIN) -----
0030FD 121DA1            LCALL    _drv_c2m_WriteData
003100         ?L?COM0027:
003100 E4                CLR      A
003101 753410            MOV      _timeout+03H,#010H
003104 753327            MOV      _timeout+02H,#027H
003107 F532              MOV      _timeout+01H,A
003109 F531              MOV      _timeout,A
00310B 22                RET      
----- FUNCTION ?L?COM0026 (END) -------


----- FUNCTION ?L?COM002A (BEGIN) -----
00310C 122000            LCALL    c2m_ReadDR
00310F EF                MOV      A,R7
003110 640D              XRL      A,#0DH
003112 22                RET      
----- FUNCTION ?L?COM002A (END) -------


----- FUNCTION ?L?COM002D (BEGIN) -----
003113 9001AC            MOV      DPTR,#vCmdBufCount
003116 E0                MOVX     A,@DPTR
003117 D3                SETB     C
003118 9400              SUBB     A,#00H
00311A 22                RET      
----- FUNCTION ?L?COM002D (END) -------


----- FUNCTION ?L?COM002F (BEGIN) -----
00311B F583              MOV      DPH,A
00311D 7401              MOV      A,#01H
00311F 93                MOVC     A,@A+DPTR
003120 FA                MOV      R2,A
003121 7402              MOV      A,#02H
003123 93                MOVC     A,@A+DPTR
003124 F9                MOV      R1,A
003125 120311            LCALL    ?C?ICALL
003128 0523              INC      i
00312A E523              MOV      A,i
00312C C3                CLR      C
00312D 22                RET      
----- FUNCTION ?L?COM002F (END) -------


----- FUNCTION ?L?COM0036 (BEGIN) -----
00312E 7533FF            MOV      ?_printf?BYTE+03H,#0FFH
003131 75340B            MOV      ?_printf?BYTE+04H,#HIGH 01000B3DH
003134 75353D            MOV      ?_printf?BYTE+05H,#LOW 01000B3DH
003137 7BFF              MOV      R3,#0FFH
003139 7A0B              MOV      R2,#HIGH 01000BA5H
00313B 79A5              MOV      R1,#LOW 01000BA5H
00313D 22                RET      
----- FUNCTION ?L?COM0036 (END) -------
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 86




----- FUNCTION ?L?COM0037 (BEGIN) -----
00313E D297              SETB     IO_C2M_SCL
003140 53A6FE            ANL      P2MDOUT,#0FEH
003143 D2A0              SETB     IO_C2M_SDA
003145 C297              CLR      IO_C2M_SCL
003147 22                RET      
----- FUNCTION ?L?COM0037 (END) -------


----- FUNCTION ?L?COM0038 (BEGIN) -----
003148 121DA1            LCALL    _drv_c2m_WriteData
00314B E4                CLR      A
00314C 753510            MOV      _timeout+03H,#010H
00314F 753427            MOV      _timeout+02H,#027H
003152 F533              MOV      _timeout+01H,A
003154 F532              MOV      _timeout,A
003156 22                RET      
----- FUNCTION ?L?COM0038 (END) -------


----- FUNCTION ?L?COM0039 (BEGIN) -----
003157 121DA1            LCALL    _drv_c2m_WriteData
00315A E4                CLR      A
00315B 752C10            MOV      _timeout+03H,#010H
00315E 752B27            MOV      _timeout+02H,#027H
003161 F52A              MOV      _timeout+01H,A
003163 F529              MOV      _timeout,A
003165 22                RET      
----- FUNCTION ?L?COM0039 (END) -------


----- FUNCTION ?L?COM003A (BEGIN) -----
003166 121DA1            LCALL    _drv_c2m_WriteData
003169 E4                CLR      A
00316A 752F10            MOV      _timeout+03H,#010H
00316D 752E27            MOV      _timeout+02H,#027H
003170 F52D              MOV      _timeout+01H,A
003172 F52C              MOV      _timeout,A
003174 22                RET      
----- FUNCTION ?L?COM003A (END) -------


----- FUNCTION ?L?COM003B (BEGIN) -----
003175 FC                MOV      R4,A
003176 7401              MOV      A,#01H
003178 93                MOVC     A,@A+DPTR
003179 2F                ADD      A,R7
00317A F582              MOV      DPL,A
00317C EC                MOV      A,R4
00317D 3E                ADDC     A,R6
00317E F583              MOV      DPH,A
003180 E4                CLR      A
003181 93                MOVC     A,@A+DPTR
003182 22                RET      
----- FUNCTION ?L?COM003B (END) -------


----- FUNCTION ?L?COM003D (BEGIN) -----
003183 90015B            MOV      DPTR,#aCmdBuf
003186 F0                MOVX     @DPTR,A
003187 9001AC            MOV      DPTR,#vCmdBufCount
00318A F0                MOVX     @DPTR,A
00318B 900014            MOV      DPTR,#vCmdParamCount
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 87


00318E F0                MOVX     @DPTR,A
00318F 22                RET      
----- FUNCTION ?L?COM003D (END) -------


----- FUNCTION ?L?COM003E (BEGIN) -----
003190 745B              MOV      A,#LOW aCmdBuf
003192 2F                ADD      A,R7
003193 F9                MOV      R1,A
003194 E4                CLR      A
003195 3401              ADDC     A,#HIGH aCmdBuf
003197 A801              MOV      R0,AR1
003199 FC                MOV      R4,A
00319A 7D01              MOV      R5,#01H
00319C 22                RET      
----- FUNCTION ?L?COM003E (END) -------


----- FUNCTION ?L?COM0041 (BEGIN) -----
00319D 745B              MOV      A,#LOW aCmdBuf
00319F 2527              ADD      A,i
0031A1 F582              MOV      DPL,A
0031A3 E4                CLR      A
0031A4 3401              ADDC     A,#HIGH aCmdBuf
0031A6 F583              MOV      DPH,A
0031A8 22                RET      
----- FUNCTION ?L?COM0041 (END) -------


----- FUNCTION ?L?COM0042 (BEGIN) -----
0031A9 E0                MOVX     A,@DPTR
0031AA FF                MOV      R7,A
0031AB 245C              ADD      A,#LOW aCmdBuf+01H
0031AD F9                MOV      R1,A
0031AE E4                CLR      A
0031AF 3401              ADDC     A,#HIGH aCmdBuf+01H
0031B1 FA                MOV      R2,A
0031B2 7B01              MOV      R3,#01H
0031B4 22                RET      
----- FUNCTION ?L?COM0042 (END) -------


----- FUNCTION ?L?COM0045 (BEGIN) -----
0031B5 F583              MOV      DPH,A
0031B7 E4                CLR      A
0031B8 F0                MOVX     @DPTR,A
0031B9 0F                INC      R7
0031BA 0F                INC      R7
0031BB 22                RET      
----- FUNCTION ?L?COM0045 (END) -------


----- FUNCTION ?L?COM0046 (BEGIN) -----
0031BC 93                MOVC     A,@A+DPTR
0031BD F524              MOV      vData,A
0031BF C3                CLR      C
0031C0 9420              SUBB     A,#020H
0031C2 22                RET      
----- FUNCTION ?L?COM0046 (END) -------


----- FUNCTION ?L?COM0047 (BEGIN) -----
0031C3 D297              SETB     IO_C2M_SCL
0031C5 A217              MOV      C,bLength1
0031C7 92A0              MOV      IO_C2M_SDA,C
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 88


0031C9 C297              CLR      IO_C2M_SCL
0031CB 22                RET      
----- FUNCTION ?L?COM0047 (END) -------


----- FUNCTION ?L?COM0048 (BEGIN) -----
0031CC D297              SETB     IO_C2M_SCL
0031CE A216              MOV      C,bLength0
0031D0 92A0              MOV      IO_C2M_SDA,C
0031D2 C297              CLR      IO_C2M_SCL
0031D4 22                RET      
----- FUNCTION ?L?COM0048 (END) -------


----- FUNCTION ?L?COM0049 (BEGIN) -----
0031D5 D297              SETB     IO_C2M_SCL
0031D7 A207              MOV      C,bC2Bit7
0031D9 92A0              MOV      IO_C2M_SDA,C
0031DB C297              CLR      IO_C2M_SCL
0031DD 22                RET      
----- FUNCTION ?L?COM0049 (END) -------


----- FUNCTION ?L?COM004A (BEGIN) -----
0031DE D297              SETB     IO_C2M_SCL
0031E0 A206              MOV      C,bC2Bit6
0031E2 92A0              MOV      IO_C2M_SDA,C
0031E4 C297              CLR      IO_C2M_SCL
0031E6 22                RET      
----- FUNCTION ?L?COM004A (END) -------


----- FUNCTION ?L?COM004B (BEGIN) -----
0031E7 D297              SETB     IO_C2M_SCL
0031E9 A205              MOV      C,bC2Bit5
0031EB 92A0              MOV      IO_C2M_SDA,C
0031ED C297              CLR      IO_C2M_SCL
0031EF 22                RET      
----- FUNCTION ?L?COM004B (END) -------


----- FUNCTION ?L?COM004C (BEGIN) -----
0031F0 D297              SETB     IO_C2M_SCL
0031F2 A204              MOV      C,bC2Bit4
0031F4 92A0              MOV      IO_C2M_SDA,C
0031F6 C297              CLR      IO_C2M_SCL
0031F8 22                RET      
----- FUNCTION ?L?COM004C (END) -------


----- FUNCTION ?L?COM004D (BEGIN) -----
0031F9 D297              SETB     IO_C2M_SCL
0031FB A203              MOV      C,bC2Bit3
0031FD 92A0              MOV      IO_C2M_SDA,C
0031FF C297              CLR      IO_C2M_SCL
003201 22                RET      
----- FUNCTION ?L?COM004D (END) -------


----- FUNCTION ?L?COM004E (BEGIN) -----
003202 D297              SETB     IO_C2M_SCL
003204 A202              MOV      C,bC2Bit2
003206 92A0              MOV      IO_C2M_SDA,C
003208 C297              CLR      IO_C2M_SCL
00320A 22                RET      
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:14:41  PAGE 89


----- FUNCTION ?L?COM004E (END) -------


----- FUNCTION ?L?COM004F (BEGIN) -----
00320B D297              SETB     IO_C2M_SCL
00320D A201              MOV      C,bC2Bit1
00320F 92A0              MOV      IO_C2M_SDA,C
003211 C297              CLR      IO_C2M_SCL
003213 22                RET      
----- FUNCTION ?L?COM004F (END) -------


----- FUNCTION ?L?COM0050 (BEGIN) -----
003214 D297              SETB     IO_C2M_SCL
003216 A200              MOV      C,bC2Bit0
003218 92A0              MOV      IO_C2M_SDA,C
00321A C297              CLR      IO_C2M_SCL
00321C 22                RET      
----- FUNCTION ?L?COM0050 (END) -------


----- FUNCTION ?L?COM0051 (BEGIN) -----
00321D 852B82            MOV      DPL,p+01H
003220 852A83            MOV      DPH,p
003223 E0                MOVX     A,@DPTR
003224 22                RET      
----- FUNCTION ?L?COM0051 (END) -------


----- FUNCTION ?L?COM0052 (BEGIN) -----
003225 AF14              MOV      R7,vFPDAT
003227 12214E            LCALL    _c2m_WriteAR
00322A 7F02              MOV      R7,#02H
00322C 22                RET      
----- FUNCTION ?L?COM0052 (END) -------


