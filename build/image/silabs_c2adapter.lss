LX51 LINKER/LOCATER V4.66.41.0                                                          06/14/2016  11:49:58  PAGE 1





ASSEMBLER CODE PACKING OF MODULE:  ..\build\obj\silabs_c2adapter (THREAD_PKT)


----- FUNCTION APL_Entry (BEGIN) -----
 FILE: '..\apl\apl.c'
   36: void APL_Entry(void)
   37: {
   38:     /* do nothing */
   39: }
00002A 22                RET      
----- FUNCTION APL_Entry (END) -------


00002B 020E17            LJMP     0E17H
----- FUNCTION DRV_VECTOR_UserUSB (BEGIN) -----
 FILE: '..\drv\drv_vector.c'
   65: void DRV_VECTOR_UserUSB(void) __interrupt(INTERRUPT_UserUSB)
   66: {
   67:   #if PKT_SUPPORT
   68: 	thread_Pkt_Notify(DRV_USB_GetInterruptSource());
   69:   #endif
   70: }
000042 32                RETI     
----- FUNCTION DRV_VECTOR_UserUSB (END) -------


000083 80BD              SJMP     01000042H
----- FUNCTION APL_Init (BEGIN) -----
 FILE: '..\apl\apl.c'
   56: void APL_Init(void)
   57: {
   58:     /* perform entry once */
   59:     APL_Entry();
0001D6 012A              AJMP     APL_Entry
----- FUNCTION APL_Init (END) -------


----- FUNCTION thread_LED_Init (BEGIN) -----
 FILE: '..\plf\thread_led.c'
   77: void thread_LED_Init(void)
   78: {
   79:     PT_INIT(&vTCB_LED);
   80: }
0001D8 E4                CLR      A
0001D9 F514              MOV      vTCB_LED,A
0001DB F515              MOV      vTCB_LED+01H,A
   81: 
0001DD 22                RET      
----- FUNCTION thread_LED_Init (END) -------


----- FUNCTION thread_IDLE_Entry (BEGIN) -----
 FILE: '..\plf\thread_idle.c'
   38: OS_HANDLE thread_IDLE_Entry(void)
   39: {
   40:     PT_BEGIN(&vTCB_Idle);
   41: 
000B92 750901            MOV      PT_YIELD_FLAG,#01H
000B95         ?C0001?THREAD_IDLE:
000B95 E512              MOV      A,vTCB_Idle
000B97 7031              JNZ      ?C0002?THREAD_IDLE
000B99 E513              MOV      A,vTCB_Idle+01H
000B9B 24CF              ADD      A,#0CFH
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:49:58  PAGE 2


000B9D 6019              JZ       ?C0012?THREAD_IDLE
000B9F 2431              ADD      A,#031H
000BA1 7027              JNZ      ?C0002?THREAD_IDLE
   42:     for (;;)
000BA3         ?C0004?THREAD_IDLE:
   43:     {
   44:     	/* system entry */
   45:         CFG_Entry();
   46:         DRV_Entry();
   47:         APL_Entry();
000BA3 12002A            LCALL    APL_Entry
   48: 
   49:         OS_SLEEP_MS(&vTCB_Idle, 50);
000BA6 E511              MOV      A,vTickCount+03H
000BA8 2432              ADD      A,#032H
000BAA D173              ACALL    ?L?COM0003
000BAC 900078            MOV      DPTR,#vEndTick
000BAF 120482            LCALL    ?C?LSTXDATA
000BB2 751200            MOV      vTCB_Idle,#00H
000BB5 751331            MOV      vTCB_Idle+01H,#031H
000BB8         ?C0012?THREAD_IDLE:
000BB8 00                NOP      
000BB9 900078            MOV      DPTR,#vEndTick
000BBC D14E              ACALL    ?L?COM0001
000BBE 7F00              MOV      R7,#00H
000BC0 5002              JNC      ?C0014?THREAD_IDLE
000BC2 7F01              MOV      R7,#01H
000BC4         ?C0014?THREAD_IDLE:
000BC4         ?C0015?THREAD_IDLE:
000BC4 EF                MOV      A,R7
000BC5 60DC              JZ       ?C0004?THREAD_IDLE
000BC7 7F00              MOV      R7,#00H
000BC9 22                RET      
   50:     }
   51: 
   52:     PT_END(&vTCB_Idle);
000BCA         ?C0002?THREAD_IDLE:
000BCA E4                CLR      A
000BCB F509              MOV      PT_YIELD_FLAG,A
000BCD F512              MOV      vTCB_Idle,A
000BCF F513              MOV      vTCB_Idle+01H,A
000BD1 7F03              MOV      R7,#03H
   53: }
000BD3 22                RET      
----- FUNCTION thread_IDLE_Entry (END) -------


----- FUNCTION thread_IDLE_Init (BEGIN) -----
 FILE: '..\plf\thread_idle.c'
   70: void thread_IDLE_Init(void)
   71: {
   72:     PT_INIT(&vTCB_Idle);
   73: 
000BD4 E4                CLR      A
000BD5 F512              MOV      vTCB_Idle,A
000BD7 F513              MOV      vTCB_Idle+01H,A
   74: 	/* system init */
   75:     CFG_Init();
   76:     DRV_Init();
000BD9 9120              ACALL    DRV_Init
   77:     APL_Init();
000BDB 0201D6            LJMP     APL_Init
----- FUNCTION thread_IDLE_Init (END) -------


LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:49:58  PAGE 3


----- FUNCTION thread_LED_Entry (BEGIN) -----
 FILE: '..\plf\thread_led.c'
   37: OS_HANDLE thread_LED_Entry(void)
   38: {
   39:     PT_BEGIN(&vTCB_LED);
   40: 
000BDE 750901            MOV      PT_YIELD_FLAG,#01H
000BE1         ?C0001?THREAD_LED:
000BE1 E514              MOV      A,vTCB_LED
000BE3 7031              JNZ      ?C0002?THREAD_LED
000BE5 E515              MOV      A,vTCB_LED+01H
000BE7 24C8              ADD      A,#0C8H
000BE9 6019              JZ       ?C0015?THREAD_LED
000BEB 2438              ADD      A,#038H
000BED 7027              JNZ      ?C0002?THREAD_LED
   41:     for (;;)
   42:     {
   43:       #if CFG_SUPPORT
   44:         if (CFG_GET(RT_EVB_STAT_Global_Ready) == HIGH)
   45:         {
   46:             /* system running OK */
   47:             DRV_IO_Write(IO(IO_LED_STATUS_OUT), LOW);
   48:         }
   49:         else
   50:       #endif
   51:         {
000BEF         ?C0008?THREAD_LED:
   52:             /* system running abnormally */
   53:             DRV_IO_Toggle(IO(IO_LED_STATUS_OUT));
000BEF 63A008            XRL      P2,#08H
   54:         }
   55: 
   56:         OS_SLEEP_MS(&vTCB_LED, 100);
000BF2 E511              MOV      A,vTickCount+03H
000BF4 2464              ADD      A,#064H
000BF6 D173              ACALL    ?L?COM0003
000BF8 90007C            MOV      DPTR,#vEndTick
000BFB 120482            LCALL    ?C?LSTXDATA
000BFE 751400            MOV      vTCB_LED,#00H
000C01 751538            MOV      vTCB_LED+01H,#038H
000C04         ?C0015?THREAD_LED:
000C04 00                NOP      
000C05 90007C            MOV      DPTR,#vEndTick
000C08 D14E              ACALL    ?L?COM0001
000C0A 7F00              MOV      R7,#00H
000C0C 5002              JNC      ?C0017?THREAD_LED
000C0E 7F01              MOV      R7,#01H
000C10         ?C0017?THREAD_LED:
000C10         ?C0018?THREAD_LED:
000C10 EF                MOV      A,R7
000C11 60DC              JZ       ?C0008?THREAD_LED
000C13 7F00              MOV      R7,#00H
000C15 22                RET      
   57:     }
   58: 
   59:     PT_END(&vTCB_LED);
000C16         ?C0002?THREAD_LED:
000C16 E4                CLR      A
000C17 F509              MOV      PT_YIELD_FLAG,A
000C19 F514              MOV      vTCB_LED,A
000C1B F515              MOV      vTCB_LED+01H,A
000C1D 7F03              MOV      R7,#03H
   60: }
000C1F 22                RET      
----- FUNCTION thread_LED_Entry (END) -------
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:49:58  PAGE 4




----- FUNCTION DRV_Init (BEGIN) -----
 FILE: '..\drv\drv.c'
   36: void DRV_Init(void)
   37: {
   38: 	DRV_VECTOR_Init();
   39: 
   40:   #if DRV_FLASH_SUPPORT
   41: 	DRV_FLASH_Init();
   42:   #endif
   43: 
   44:   #if DRV_RESET_SUPPORT
   45: 	DRV_RESET_Init();
   46:   #endif
   47: 
   48:   #if DRV_TIMER_SUPPORT
   49: 	DRV_TIMER_Init();
000C20 438E10            ORL      CKCON,#010H
000C23 E4                CLR      A
000C24 F5C8              MOV      TMR2CN,A
000C26 75CA40            MOV      TMR2RLL,#040H
000C29 75CC40            MOV      TMR2L,#040H
000C2C 75CBA2            MOV      TMR2RLH,#0A2H
000C2F 75CDA2            MOV      TMR2H,#0A2H
000C32 C2CF              CLR      TF2H
000C34 D2CA              SETB     TR2
000C36 C2BD              CLR      PT2
000C38 D2AD              SETB     ET2
000C3A F511              MOV      vTickCount+03H,A
000C3C F510              MOV      vTickCount+02H,A
000C3E F50F              MOV      vTickCount+01H,A
000C40 F50E              MOV      vTickCount,A
;----                  JMP      DRV_USB_Init
   50:   #endif
   51: 
   52:   #if DRV_USB_SUPPORT
----- FUNCTION DRV_Init (END) -------


----- FUNCTION DRV_USB_Init (BEGIN) -----
 FILE: '..\drv\drv_usb.c'
   44: void DRV_USB_Init(void)
   45: {
   46:     static SEG_CODE UINT8 aVN[DRV_USB_STRING_MAX_LEN+1] = DRV_USB_VendorName;
   47:     static SEG_CODE UINT8 aPN[DRV_USB_STRING_MAX_LEN+1] = DRV_USB_PartNumber;
   48:     static SEG_CODE UINT8 aSN[DRV_USB_STRING_MAX_LEN+1] = DRV_USB_SerialNumber;
   49:     UINT8   vData;
   50:     UINT8   vLoop;
   51: 
   52:     /* init USB manufacture string */
   53:     aManufacturerStr[1] = 0x03;
000C42 900001            MOV      DPTR,#aManufacturerStr+01H
000C45 7403              MOV      A,#03H
000C47 F0                MOVX     @DPTR,A
   54:     for (vLoop=2; vLoop<sizeof(aManufacturerStr); vLoop+=2)
;---- Variable 'vLoop' assigned to Register 'R7' ----
000C48 7F02              MOV      R7,#02H
000C4A         ?C0001?DRV_USB:
000C4A EF                MOV      A,R7
000C4B C3                CLR      C
000C4C 9422              SUBB     A,#022H
000C4E 5029              JNC      ?C0002?DRV_USB
   55:     {
   56:         vData = aVN[(vLoop>>1)-1];
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:49:58  PAGE 5


000C50 EF                MOV      A,R7
000C51 C3                CLR      C
000C52 13                RRC      A
000C53 900B52            MOV      DPTR,#aVN-01H
000C56 D16C              ACALL    ?L?COM0005
000C58 401F              JC       ?C0002?DRV_USB
000C5A E509              MOV      A,vData
000C5C 947F              SUBB     A,#07FH
000C5E 5019              JNC      ?C0002?DRV_USB
   57: 
   58:         if ((vData < 0x20) || (vData >= 0x7F))
   59:         {
   60:             break;
   61:         }
000C60         ?C0004?DRV_USB:
   62: 
   63:         aManufacturerStr[vLoop+0] = vData;
000C60 7400              MOV      A,#LOW aManufacturerStr
000C62 2F                ADD      A,R7
000C63 F582              MOV      DPL,A
000C65 E4                CLR      A
000C66 3400              ADDC     A,#HIGH aManufacturerStr
000C68 F583              MOV      DPH,A
000C6A E509              MOV      A,vData
000C6C F0                MOVX     @DPTR,A
   64:         aManufacturerStr[vLoop+1] = 0;
000C6D 7401              MOV      A,#LOW aManufacturerStr+01H
000C6F 2F                ADD      A,R7
000C70 F582              MOV      DPL,A
000C72 E4                CLR      A
000C73 3400              ADDC     A,#HIGH aManufacturerStr+01H
000C75 D165              ACALL    ?L?COM0004
000C77 80D1              SJMP     ?C0001?DRV_USB
000C79         ?C0002?DRV_USB:
   65:     }
   66:     aManufacturerStr[0] = vLoop;
000C79 900000            MOV      DPTR,#aManufacturerStr
000C7C EF                MOV      A,R7
000C7D F0                MOVX     @DPTR,A
   67: 
   68:     /* init USB product string */
   69:     aProductStr[1] = 0x03;
000C7E 900023            MOV      DPTR,#aProductStr+01H
000C81 7403              MOV      A,#03H
000C83 F0                MOVX     @DPTR,A
   70:     for (vLoop=2; vLoop<sizeof(aProductStr); vLoop+=2)
000C84 7F02              MOV      R7,#02H
000C86         ?C0006?DRV_USB:
000C86 EF                MOV      A,R7
000C87 C3                CLR      C
000C88 9422              SUBB     A,#022H
000C8A 5029              JNC      ?C0007?DRV_USB
   71:     {
   72:         vData = aPN[(vLoop>>1)-1];
000C8C EF                MOV      A,R7
000C8D C3                CLR      C
000C8E 13                RRC      A
000C8F 900B63            MOV      DPTR,#aPN-01H
000C92 D16C              ACALL    ?L?COM0005
000C94 401F              JC       ?C0007?DRV_USB
000C96 E509              MOV      A,vData
000C98 947F              SUBB     A,#07FH
000C9A 5019              JNC      ?C0007?DRV_USB
   73: 
   74:         if ((vData < 0x20) || (vData >= 0x7F))
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:49:58  PAGE 6


   75:         {
   76:             break;
   77:         }
000C9C         ?C0009?DRV_USB:
   78: 
   79:         aProductStr[vLoop+0] = vData;
000C9C 7422              MOV      A,#LOW aProductStr
000C9E 2F                ADD      A,R7
000C9F F582              MOV      DPL,A
000CA1 E4                CLR      A
000CA2 3400              ADDC     A,#HIGH aProductStr
000CA4 F583              MOV      DPH,A
000CA6 E509              MOV      A,vData
000CA8 F0                MOVX     @DPTR,A
   80:         aProductStr[vLoop+1] = 0;
000CA9 7423              MOV      A,#LOW aProductStr+01H
000CAB 2F                ADD      A,R7
000CAC F582              MOV      DPL,A
000CAE E4                CLR      A
000CAF 3400              ADDC     A,#HIGH aProductStr+01H
000CB1 D165              ACALL    ?L?COM0004
000CB3 80D1              SJMP     ?C0006?DRV_USB
000CB5         ?C0007?DRV_USB:
   81:     }
   82:     aProductStr[0] = vLoop;
000CB5 900022            MOV      DPTR,#aProductStr
000CB8 EF                MOV      A,R7
000CB9 F0                MOVX     @DPTR,A
   83: 
   84:     /* init USB serial number string */
   85:     aSerialNumberStr[1] = 0x03;
000CBA 900045            MOV      DPTR,#aSerialNumberStr+01H
000CBD 7403              MOV      A,#03H
000CBF F0                MOVX     @DPTR,A
   86:     for (vLoop=2; vLoop<sizeof(aSerialNumberStr); vLoop+=2)
000CC0 7F02              MOV      R7,#02H
000CC2         ?C0011?DRV_USB:
000CC2 EF                MOV      A,R7
000CC3 C3                CLR      C
000CC4 9422              SUBB     A,#022H
000CC6 5029              JNC      ?C0012?DRV_USB
   87:     {
   88:         vData = aSN[(vLoop>>1)-1];
000CC8 EF                MOV      A,R7
000CC9 C3                CLR      C
000CCA 13                RRC      A
000CCB 900B74            MOV      DPTR,#aSN-01H
000CCE D16C              ACALL    ?L?COM0005
000CD0 401F              JC       ?C0012?DRV_USB
000CD2 E509              MOV      A,vData
000CD4 947F              SUBB     A,#07FH
000CD6 5019              JNC      ?C0012?DRV_USB
   89: 
   90:         if ((vData < 0x20) || (vData >= 0x7F))
   91:         {
   92:             break;
   93:         }
000CD8         ?C0014?DRV_USB:
   94: 
   95:         aSerialNumberStr[vLoop+0] = vData;
000CD8 7444              MOV      A,#LOW aSerialNumberStr
000CDA 2F                ADD      A,R7
000CDB F582              MOV      DPL,A
000CDD E4                CLR      A
000CDE 3400              ADDC     A,#HIGH aSerialNumberStr
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:49:58  PAGE 7


000CE0 F583              MOV      DPH,A
000CE2 E509              MOV      A,vData
000CE4 F0                MOVX     @DPTR,A
   96:         aSerialNumberStr[vLoop+1] = 0;
000CE5 7445              MOV      A,#LOW aSerialNumberStr+01H
000CE7 2F                ADD      A,R7
000CE8 F582              MOV      DPL,A
000CEA E4                CLR      A
000CEB 3400              ADDC     A,#HIGH aSerialNumberStr+01H
000CED D165              ACALL    ?L?COM0004
000CEF 80D1              SJMP     ?C0011?DRV_USB
000CF1         ?C0012?DRV_USB:
   97:     }
   98:     aSerialNumberStr[0] = vLoop;
000CF1 900044            MOV      DPTR,#aSerialNumberStr
000CF4 EF                MOV      A,R7
000CF5 F0                MOVX     @DPTR,A
   99: 
  100:     /* set USB0 to the high priority level interrupt */
  101:     EIP1 |= (1<<1);
000CF6 43F602            ORL      EIP1,#02H
  102: 
  103:     /* init USB device */
  104:     USB_Clock_Start();
000CF9 120046            LCALL    USB_Clock_Start
  105:     USB_Init(DRV_USB_VID,
000CFC 90006D            MOV      DPTR,#?_USB_Init?BYTE+07H
000CFF 7401              MOV      A,#01H
000D01 F0                MOVX     @DPTR,A
000D02 A3                INC      DPTR
000D03 7400              MOV      A,#HIGH aProductStr
000D05 F0                MOVX     @DPTR,A
000D06 A3                INC      DPTR
000D07 7422              MOV      A,#LOW aProductStr
000D09 F0                MOVX     @DPTR,A
000D0A A3                INC      DPTR
000D0B 7401              MOV      A,#01H
000D0D F0                MOVX     @DPTR,A
000D0E A3                INC      DPTR
000D0F 7400              MOV      A,#HIGH aSerialNumberStr
000D11 F0                MOVX     @DPTR,A
000D12 A3                INC      DPTR
000D13 7444              MOV      A,#LOW aSerialNumberStr
000D15 F0                MOVX     @DPTR,A
000D16 A3                INC      DPTR
000D17 74FA              MOV      A,#0FAH
000D19 F0                MOVX     @DPTR,A
000D1A A3                INC      DPTR
000D1B 7480              MOV      A,#080H
000D1D F0                MOVX     @DPTR,A
000D1E A3                INC      DPTR
000D1F 7401              MOV      A,#01H
000D21 F0                MOVX     @DPTR,A
000D22 A3                INC      DPTR
000D23 E4                CLR      A
000D24 F0                MOVX     @DPTR,A
000D25 7B01              MOV      R3,#01H
000D27 7A00              MOV      R2,#HIGH aManufacturerStr
000D29 7900              MOV      R1,#LOW aManufacturerStr
000D2B 7D61              MOV      R5,#061H
000D2D 7CEA              MOV      R4,#0EAH
000D2F 7FC4              MOV      R7,#0C4H
000D31 7E10              MOV      R6,#010H
000D33 12057D            LCALL    _USB_Init
  106:              DRV_USB_PID,
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:49:58  PAGE 8


  107:              aManufacturerStr,
  108:              aProductStr,
  109:              aSerialNumberStr,
  110:              0xFA,      /* maximum current: 500mA */
  111:              0x80,      /* bus-powered, remote wakeup is unsupported */
  112:              0x100);    /* device release number 1.00 */
  113: 
  114:     /* the USB_Init() API will auto-enable global interrupt,
  115:      * disable it here, and will be enabled later.
  116:      */
  117:     DRV_INT_GlobalDisableInterrupt();
000D36 C2AF              CLR      EA
  118: }
000D38 22                RET      
----- FUNCTION DRV_USB_Init (END) -------


----- FUNCTION _fixupInit (BEGIN) -----
 FILE: '..\plf\main.c'
   35: static void _fixupInit(void)
   36: {
   37:     /* Globally enable Interrupt */
   38:     DRV_INT_GlobalEnableInterrupt();
000D39 D2AF              SETB     EA
   39: 
   40:   #if DRV_USB_SUPPORT
   41: 	/* enable USB interface */
   42: 	DRV_USB_Enable();
000D3B 612E              AJMP     USB_Int_Enable
----- FUNCTION _fixupInit (END) -------


----- FUNCTION main (BEGIN) -----
 FILE: '..\plf\main.c'
   61: void main(void)
   62: {
   63: 	/* previous init */
   64: 	DRV_PreInit();
000D3D B16E              ACALL    DRV_PreInit
   65: 
   66:     /* init protothread */
   67:     OS_Init();
000D3F B159              ACALL    OS_Init
   68: 
   69:     /* fixup init */
   70:     _fixupInit();
000D41 B139              ACALL    _fixupInit
;----                  JMP      OS_Start
   71: 
   72:     /* start protothread (never return) */
----- FUNCTION main (END) -------


----- FUNCTION OS_Start (BEGIN) -----
 FILE: '..\os\os.c'
   48: void OS_Start(void)
   49: {
   50:     for (;;)
   51:     {
000D43         ?C0001?OS:
   52:         UINT8   i;
   53: 
   54:         for (i = 0; i < COUNT_OF(aThreadList); i++)
000D43 E4                CLR      A
000D44 F508              MOV      i,A
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:49:58  PAGE 9


000D46         ?C0003?OS:
   55:         {
   56:             aThreadList[i].pEntry();
000D46 E508              MOV      A,i
000D48 75F006            MOV      B,#06H
000D4B A4                MUL      AB
000D4C 2486              ADD      A,#LOW aThreadList
000D4E F582              MOV      DPL,A
000D50 E4                CLR      A
000D51 340B              ADDC     A,#HIGH aThreadList
000D53 D181              ACALL    ?L?COM0002
000D55 40EF              JC       ?C0003?OS
000D57 80EA              SJMP     ?C0001?OS
   57:         }
----- FUNCTION OS_Start (END) -------


----- FUNCTION OS_Init (BEGIN) -----
 FILE: '..\os\os.c'
   76: void OS_Init(void)
   77: {
   78:     UINT8   i;
   79: 
   80:     for (i = 0; i < COUNT_OF(aThreadList); i++)
000D59 E4                CLR      A
000D5A F508              MOV      i,A
000D5C         ?C0007?OS:
   81:     {
   82:         aThreadList[i].pInit();
000D5C E508              MOV      A,i
000D5E 75F006            MOV      B,#06H
000D61 A4                MUL      AB
000D62 2489              ADD      A,#LOW aThreadList+03H
000D64 F582              MOV      DPL,A
000D66 E4                CLR      A
000D67 340B              ADDC     A,#HIGH aThreadList+03H
000D69 D181              ACALL    ?L?COM0002
000D6B 40EF              JC       ?C0007?OS
   83:     }
   84: }
000D6D 22                RET      
----- FUNCTION OS_Init (END) -------


----- FUNCTION DRV_PreInit (BEGIN) -----
 FILE: '..\drv\drv.c'
   88: void DRV_PreInit(void)
   89: {
   90:     /* disable all interrupt */
   91:     DRV_INT_DisableAllInterrupt();
000D6E E4                CLR      A
000D6F F5A8              MOV      IE,A
000D71 F5E6              MOV      EIE1,A
   92: 
   93:   #if DRV_CLOCK_SUPPORT
   94:     DRV_CLOCK_Init();
000D73 75B283            MOV      OSCICN,#083H
000D76         ?C0023?DRV:
000D76 E5B2              MOV      A,OSCICN
000D78 C4                SWAP     A
000D79 13                RRC      A
000D7A 13                RRC      A
000D7B 5403              ANL      A,#03H
000D7D 13                RRC      A
000D7E 50F6              JNC      ?C0023?DRV
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:49:58  PAGE 10


000D80         ?C0024?DRV:
000D80 75B980            MOV      CLKMUL,#080H
000D83 7F05              MOV      R7,#05H
000D85 7E00              MOV      R6,#00H
000D87 B1C4              ACALL    _DRV_CPU_DelayUs
000D89 43B9C0            ORL      CLKMUL,#0C0H
000D8C         ?C0025?DRV:
000D8C E5B9              MOV      A,CLKMUL
000D8E C4                SWAP     A
000D8F 13                RRC      A
000D90 5407              ANL      A,#07H
000D92 13                RRC      A
000D93 50F7              JNC      ?C0025?DRV
000D95         ?C0026?DRV:
000D95 75A902            MOV      CLKSEL,#02H
000D98 75B680            MOV      FLSCL,#080H
   95:   #endif
   96: 
   97:   #if DRV_IO_SUPPORT
   98: 	DRV_IO_Init();
000D9B B1E4              ACALL    DRV_IO_Init
   99:   #endif
  100: 
  101:   #if DRV_UART_SUPPORT
  102:     DRV_UART_Init();
000D9D 438E08            ORL      CKCON,#08H
000DA0 E589              MOV      A,TMOD
000DA2 540F              ANL      A,#0FH
000DA4 4420              ORL      A,#020H
000DA6 F589              MOV      TMOD,A
000DA8 758D98            MOV      TH1,#098H
000DAB D28E              SETB     TR1
000DAD AFD4              MOV      R7,P0SKIP
000DAF EF                MOV      A,R7
000DB0 54EF              ANL      A,#0EFH
000DB2 FF                MOV      R7,A
000DB3 8FD4              MOV      P0SKIP,R7
000DB5 AFD4              MOV      R7,P0SKIP
000DB7 EF                MOV      A,R7
000DB8 54DF              ANL      A,#0DFH
000DBA FF                MOV      R7,A
000DBB 8FD4              MOV      P0SKIP,R7
000DBD 43E101            ORL      XBR0,#01H
000DC0 759802            MOV      SCON0,#02H
  103:   #endif
  104: 
  105:   #if DRV_PCA_SUPPORT
  106:     DRV_PCA_Init();
  107:   #endif
  108: 
  109:   #if DRV_WATCHDOG_SUPPORT
  110: 	DRV_WATCHDOG_Enable();
  111:   #endif
  112: }
000DC3 22                RET      
----- FUNCTION DRV_PreInit (END) -------


----- FUNCTION _DRV_CPU_DelayUs (BEGIN) -----
 FILE: '..\drv\drv_cpu.c'
   35: void DRV_CPU_DelayUs(UINT16 vUsec)
   36: {
;---- Variable 'vUsec' assigned to Register 'R6/R7' ----
   37:     NOP(); NOP(); NOP();
   38: 
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:49:58  PAGE 11


000DC4 8018              SJMP     ?C0013?DRV_CPU
000DC6         ?C0001?DRV_CPU:
   39:     while (--vUsec)
000DC6 EF                MOV      A,R7
000DC7 1F                DEC      R7
000DC8 7001              JNZ      ?C0011?DRV_CPU
000DCA 1E                DEC      R6
000DCB         ?C0011?DRV_CPU:
000DCB 14                DEC      A
000DCC 4E                ORL      A,R6
000DCD 6014              JZ       ?C0003?DRV_CPU
   40:     {
   41:       #if (CORE_CLOCK == 24000000UL)
   42: 		NOP(); NOP(); NOP(); NOP(); NOP();
000DCF 00                NOP      
000DD0 00                NOP      
000DD1 00                NOP      
000DD2 00                NOP      
000DD3 00                NOP      
   43: 		NOP(); NOP(); NOP(); NOP(); NOP();
000DD4 00                NOP      
000DD5 00                NOP      
000DD6 00                NOP      
000DD7 00                NOP      
000DD8 00                NOP      
   44: 		NOP(); NOP(); NOP(); NOP(); NOP();
000DD9 00                NOP      
000DDA 00                NOP      
000DDB 00                NOP      
000DDC 00                NOP      
000DDD 00                NOP      
   45: 		NOP(); NOP(); NOP();
000DDE         
000DDE 00                NOP      
000DDF 00                NOP      
000DE0 00                NOP      
   46:       #else
   47:         #error "Unsupported Core Clock!"
   48:       #endif
   49:     }
000DE1 80E3              SJMP     ?C0001?DRV_CPU
   50: }
000DE3         ?C0003?DRV_CPU:
000DE3 22                RET      
----- FUNCTION _DRV_CPU_DelayUs (END) -------


----- FUNCTION DRV_IO_Init (BEGIN) -----
 FILE: '..\drv\drv_io.c'
   37: void DRV_IO_Init(void)
   38: {
   39:     /* io internal init */
   40:     P0      = _PORT_INIT(P0);
000DE4 7580BF            MOV      P0,#0BFH
   41:     P1      = _PORT_INIT(P1);
000DE7 7590F6            MOV      P1,#0F6H
   42:     P2      = _PORT_INIT(P2);
000DEA 75A0FF            MOV      P2,#0FFH
   43:     P3      = _PORT_INIT(P3);
000DED 75B0FF            MOV      P3,#0FFH
   44:     P0MDIN  = _PORT_MDIN(P0);
000DF0 75F17F            MOV      P0MDIN,#07FH
   45:     P1MDIN  = _PORT_MDIN(P1);
000DF3 75F2FF            MOV      P1MDIN,#0FFH
   46:     P2MDIN  = _PORT_MDIN(P2);
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:49:58  PAGE 12


000DF6 75F3FB            MOV      P2MDIN,#0FBH
   47:     P3MDIN  = _PORT_MDIN(P3);
000DF9 75F4FE            MOV      P3MDIN,#0FEH
   48:     P0MDOUT = _PORT_MDOUT(P0);
000DFC 75A44A            MOV      P0MDOUT,#04AH
   49:     P1MDOUT = _PORT_MDOUT(P1);
000DFF 75A558            MOV      P1MDOUT,#058H
   50:     P2MDOUT = _PORT_MDOUT(P2);
000E02 75A60A            MOV      P2MDOUT,#0AH
   51:     P3MDOUT = _PORT_MDOUT(P3);
000E05 E4                CLR      A
000E06 F5A7              MOV      P3MDOUT,A
   52: 
   53:     /* default, all pins are skipped for cross-bar */
   54:     P0SKIP = 0xFF;
000E08 75D4FF            MOV      P0SKIP,#0FFH
   55:     P1SKIP = 0xFF;
000E0B 75D5FF            MOV      P1SKIP,#0FFH
   56:     P2SKIP = 0xFF;
000E0E 75D6FF            MOV      P2SKIP,#0FFH
   57: 
   58:     /* enable cross-bar */
   59:     XBR0 = 0x00;
000E11 F5E1              MOV      XBR0,A
   60:     XBR1 = 0x40;
000E13 75E240            MOV      XBR1,#040H
   61: }
000E16 22                RET      
----- FUNCTION DRV_IO_Init (END) -------


----- FUNCTION DRV_VECTOR_Timer2 (BEGIN) -----
 FILE: '..\drv\drv_vector.c'
   38: void DRV_VECTOR_Timer2(void) __interrupt(INTERRUPT_TIMER2)
000E17 C0E0              PUSH     ACC
000E19 C0D0              PUSH     PSW
000E1B 75D000            MOV      PSW,#00H
000E1E C004              PUSH     AR4
000E20 C005              PUSH     AR5
000E22 C006              PUSH     AR6
000E24 C007              PUSH     AR7
   39: {
   40:     /* clear timeout flag */
   41:     DRV_TIMER_ClearTimeoutFlag();
000E26 C2CF              CLR      TF2H
   42: 
   43:     /* update tick counter */
   44: 	DRV_TIMER_UpdateTick();
000E28 AF11              MOV      R7,vTickCount+03H
000E2A AE10              MOV      R6,vTickCount+02H
000E2C AD0F              MOV      R5,vTickCount+01H
000E2E AC0E              MOV      R4,vTickCount
000E30 EF                MOV      A,R7
000E31 2401              ADD      A,#01H
000E33 F511              MOV      vTickCount+03H,A
000E35 E4                CLR      A
000E36 3E                ADDC     A,R6
000E37 F510              MOV      vTickCount+02H,A
000E39 E4                CLR      A
000E3A 3D                ADDC     A,R5
000E3B F50F              MOV      vTickCount+01H,A
000E3D E4                CLR      A
000E3E 3C                ADDC     A,R4
000E3F F50E              MOV      vTickCount,A
   45: }
LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:49:58  PAGE 13


000E41 D007              POP      AR7
000E43 D006              POP      AR6
000E45 D005              POP      AR5
000E47 D004              POP      AR4
000E49 D0D0              POP      PSW
000E4B D0E0              POP      ACC
000E4D 32                RETI     
----- FUNCTION DRV_VECTOR_Timer2 (END) -------


----- FUNCTION ?L?COM0001 (BEGIN) -----
000E4E E0                MOVX     A,@DPTR
000E4F FC                MOV      R4,A
000E50 A3                INC      DPTR
000E51 E0                MOVX     A,@DPTR
000E52 FD                MOV      R5,A
000E53 A3                INC      DPTR
000E54 E0                MOVX     A,@DPTR
000E55 FE                MOV      R6,A
000E56 A3                INC      DPTR
000E57 E0                MOVX     A,@DPTR
000E58 FF                MOV      R7,A
000E59 AB11              MOV      R3,vTickCount+03H
000E5B AA10              MOV      R2,vTickCount+02H
000E5D A90F              MOV      R1,vTickCount+01H
000E5F A80E              MOV      R0,vTickCount
000E61 C3                CLR      C
000E62 020471            LJMP     ?C?ULCMP
----- FUNCTION ?L?COM0001 (END) -------


----- FUNCTION ?L?COM0004 (BEGIN) -----
000E65 F583              MOV      DPH,A
000E67 E4                CLR      A
000E68 F0                MOVX     @DPTR,A
000E69 0F                INC      R7
000E6A 0F                INC      R7
000E6B 22                RET      
----- FUNCTION ?L?COM0004 (END) -------


----- FUNCTION ?L?COM0005 (BEGIN) -----
000E6C 93                MOVC     A,@A+DPTR
000E6D F509              MOV      vData,A
000E6F C3                CLR      C
000E70 9420              SUBB     A,#020H
000E72 22                RET      
----- FUNCTION ?L?COM0005 (END) -------


----- FUNCTION ?L?COM0003 (BEGIN) -----
000E73 FF                MOV      R7,A
000E74 E4                CLR      A
000E75 3510              ADDC     A,vTickCount+02H
000E77 FE                MOV      R6,A
000E78 E4                CLR      A
000E79 350F              ADDC     A,vTickCount+01H
000E7B FD                MOV      R5,A
000E7C E4                CLR      A
000E7D 350E              ADDC     A,vTickCount
000E7F FC                MOV      R4,A
000E80 22                RET      
----- FUNCTION ?L?COM0003 (END) -------


LX51 LINKER/LOCATER V4.66.41.0                                                        06/14/2016  11:49:58  PAGE 14


----- FUNCTION ?L?COM0002 (BEGIN) -----
000E81 F583              MOV      DPH,A
000E83 7401              MOV      A,#01H
000E85 93                MOVC     A,@A+DPTR
000E86 FA                MOV      R2,A
000E87 7402              MOV      A,#02H
000E89 93                MOVC     A,@A+DPTR
000E8A F9                MOV      R1,A
000E8B 12048E            LCALL    ?C?ICALL
000E8E 0508              INC      i
000E90 E508              MOV      A,i
000E92 C3                CLR      C
000E93 9402              SUBB     A,#02H
000E95 22                RET      
----- FUNCTION ?L?COM0002 (END) -------


